// SPDX-FileCopyrightText: 2025-present Kriasoft
// SPDX-License-Identifier: MIT

import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import type { ServerWebSocket } from "@ws-kit/core";
import { z, message, createRouter } from "@ws-kit/zod";
import { createBunHandler } from "../src/index";

describe("@ws-kit/bun integration tests", () => {
  let router: any;
  let mockServer: any;

  beforeEach(() => {
    // Create a router for testing (use new Phase 2 API)
    router = createRouter();

    // Create mock Bun server
    const connections = new Map<string, any>();

    mockServer = {
      publish: (topic: string, data: string | ArrayBuffer) => {
        // Simulate broadcasting to all connections subscribed to this topic
        for (const [, ws] of connections) {
          if (ws.subscribedTopics?.has(topic)) {
            // In real Bun, this would trigger the message handler
            // For testing, we just track that it was published
          }
        }
      },
      upgrade: (req: Request, options: any) => {
        // Simulate successful upgrade
        const ws = {
          data: options.data,
          send: () => {},
          close: () => {
            connections.delete(options.data.clientId);
          },
          subscribe: (topic: string) => {
            if (!ws.subscribedTopics) ws.subscribedTopics = new Set();
            ws.subscribedTopics.add(topic);
          },
          unsubscribe: (topic: string) => {
            ws.subscribedTopics?.delete(topic);
          },
        };
        connections.set(options.data.clientId, ws);
        return ws;
      },
    };
  });

  describe("basic connection flow", () => {
    it("should handle complete lifecycle: open -> message -> close", async () => {
      const { fetch, websocket } = createBunHandler(router);
      const events: string[] = [];

      // Track events
      router.onOpen((ctx) => {
        events.push("open");
      });
      router.onClose((ctx) => {
        events.push("close");
      });

      // Create a manual WebSocket for testing lifecycle
      const testWs = {
        data: { clientId: "test-123", connectedAt: Date.now() },
        send: () => {},
        close: () => {},
        subscribe: () => {},
        unsubscribe: () => {},
      };

      // Trigger open
      await websocket.open(testWs);
      expect(events).toContain("open");

      // Trigger close
      await websocket.close(testWs, 1000, "Normal");
      expect(events).toContain("close");
    });
  });

  describe("message routing", () => {
    it("should route messages to registered handlers", async () => {
      const events: string[] = [];

      // Create a proper message schema using the message() helper
      const TestMessage = message("TEST", { text: z.string() });

      router.onMessage(TestMessage, (ctx) => {
        events.push("message");
        expect(ctx.type).toBe("TEST");
        expect(ctx.payload.text).toBeDefined();
      });

      // Verify that handlers are registered
      expect(router).toBeDefined();
      const debug = router.debug?.();
      expect(debug?.handlers?.length || 0).toBeGreaterThanOrEqual(0);
    });
  });

  describe("error handling", () => {
    it("should handle connection errors gracefully", async () => {
      const errors: Error[] = [];

      router.onError((error) => {
        errors.push(error);
      });

      // Test is mainly to ensure no crashes
      const { websocket } = createBunHandler(router);

      // Call with missing clientId
      const badWs = { data: {}, close: () => {} };
      await websocket.open(badWs);

      // Should handle gracefully (close called)
      expect(badWs).toBeDefined();
    });
  });

  describe("WebSocket data access", () => {
    it("should have clientId in ws.data", () => {
      // clientId is generated by the handler,
      // so we test that a handler doesn't throw when processing it
      let receivedClientId: string | undefined;

      router.onOpen((ctx) => {
        receivedClientId = ctx.ws.data.clientId;
      });

      const { websocket } = createBunHandler(router);
      const testWs = {
        data: {
          clientId: "test-uuid-v7-here-1234567890ab",
          connectedAt: Date.now(),
        },
        send: () => {},
        close: () => {},
        subscribe: () => {},
        unsubscribe: () => {},
      };

      // Simulate connection
      websocket.open(testWs);

      expect(receivedClientId).toBeDefined();
      expect(typeof receivedClientId).toBe("string");
    });

    it("should have connectedAt timestamp", () => {
      let receivedConnectedAt: number | undefined;

      router.onOpen((ctx) => {
        receivedConnectedAt = (ctx.ws.data as any).connectedAt;
      });

      const { websocket } = createBunHandler(router);
      const now = Date.now();
      const testWs = {
        data: { clientId: "test-id", connectedAt: now },
        send: () => {},
        close: () => {},
        subscribe: () => {},
        unsubscribe: () => {},
      };

      websocket.open(testWs);

      expect(receivedConnectedAt).toBe(now);
      expect(typeof receivedConnectedAt).toBe("number");
    });

    it("should preserve custom auth data", () => {
      let receivedUserId: string | undefined;

      router.onOpen((ctx) => {
        receivedUserId = (ctx.ws.data as any).userId;
      });

      const { websocket } = createBunHandler(router);
      const testWs = {
        data: {
          clientId: "test-id",
          connectedAt: Date.now(),
          userId: "user-123",
        },
        send: () => {},
        close: () => {},
        subscribe: () => {},
        unsubscribe: () => {},
      };

      websocket.open(testWs);

      expect(receivedUserId).toBe("user-123");
    });
  });

  describe("pub/sub integration", () => {
    it("should support message broadcasting", async () => {
      const { fetch } = createBunHandler(router);

      const req = new Request("ws://localhost/ws");
      await fetch(req, mockServer);

      // Test that router.publish can be called
      const publishPromise = router.publish("room:123", { text: "Hello" });
      expect(publishPromise).toBeInstanceOf(Promise);

      // Should resolve without error
      await publishPromise;
      expect(true).toBe(true); // Got here without error
    });
  });

  describe("upgrade response headers", () => {
    it("should include x-client-id header in upgrade response", async () => {
      const headers: Record<string, string> = {};

      const mockServerWithHeaders = {
        upgrade: (req: any, options: any) => {
          if (options.headers) {
            Object.assign(headers, options.headers);
          }
          return { ok: true };
        },
      };

      const { fetch } = createBunHandler(router);
      const req = new Request("ws://localhost/ws");
      await fetch(req, mockServerWithHeaders as any);

      expect(headers["x-client-id"]).toBeDefined();
      expect(typeof headers["x-client-id"]).toBe("string");
      expect(headers["x-client-id"]?.length).toBe(36); // UUID
    });

    it("should support custom header name", async () => {
      const headers: Record<string, string> = {};

      const mockServerWithHeaders = {
        upgrade: (req: any, options: any) => {
          if (options.headers) {
            Object.assign(headers, options.headers);
          }
          return { ok: true };
        },
      };

      const { fetch } = createBunHandler(router, {
        clientIdHeader: "x-session-id",
      });

      const req = new Request("ws://localhost/ws");
      await fetch(req, mockServerWithHeaders as any);

      expect(headers["x-session-id"]).toBeDefined();
      expect(headers["x-client-id"]).toBeUndefined();
    });
  });

  describe("async authentication", () => {
    it("should support async auth function", async () => {
      let authCalled = false;

      const asyncAuth = async (req: Request) => {
        authCalled = true;
        // Simulate some async work
        await new Promise((resolve) => setTimeout(resolve, 1));
        return { userId: "async-user" };
      };

      const { fetch } = createBunHandler(router, {
        authenticate: asyncAuth,
      });

      const req = new Request("ws://localhost/ws");
      const result = await fetch(req, mockServer);

      expect(authCalled).toBe(true);
      expect(result).toBeDefined();
    });

    it("should support sync auth function", async () => {
      let authCalled = false;

      const syncAuth = (req: Request) => {
        authCalled = true;
        return { userId: "sync-user" };
      };

      const { fetch } = createBunHandler(router, {
        authenticate: syncAuth,
      });

      const req = new Request("ws://localhost/ws");
      const result = await fetch(req, mockServer);

      expect(authCalled).toBe(true);
      expect(result).toBeDefined();
    });
  });

  describe("upgrade failure handling", () => {
    it("should return 500 when upgrade fails", async () => {
      // Mock server that fails upgrade
      const failingServer = {
        ...mockServer,
        upgrade: () => null,
      };

      const { fetch } = createBunHandler(router);

      const req = new Request("ws://localhost/ws");
      const response = await fetch(req, failingServer);

      expect(response.status).toBe(500);
    });
  });

  describe("multiple concurrent connections", () => {
    it("should handle multiple WebSocket connections without crashing", async () => {
      const { fetch } = createBunHandler(router);

      // Simulate multiple connections
      const connections = [];
      for (let i = 0; i < 5; i++) {
        const req = new Request("ws://localhost/ws");
        // Should not throw, and should handle concurrent connections
        const upgraded = await fetch(req, mockServer);
        connections.push(upgraded);
      }

      // All connections should complete successfully
      expect(connections.length).toBe(5);
    });
  });
});
