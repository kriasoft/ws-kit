import{_ as d,C as p,c as m,o as a,a2 as s,b as i,j as n,w as t,a as o,G as l,a3 as c}from"./chunks/framework.Wvl1o-t0.js";const E=JSON.parse('{"title":"State Channels Application Pattern","description":"","frontmatter":{},"headers":[],"relativePath":"patterns/state-channels.md","filePath":"patterns/state-channels.md","lastUpdated":1762079697000}'),u={name:"patterns/state-channels.md"};function h(f,e,g,S,q,C){const r=p("Mermaid");return a(),m("div",null,[e[2]||(e[2]=s('<h1 id="state-channels-application-pattern" tabindex="-1">State Channels Application Pattern <a class="header-anchor" href="#state-channels-application-pattern" aria-label="Permalink to &quot;State Channels Application Pattern&quot;">​</a></h1><p>Reliable FIFO state updates with client sequence tracking and recovery from gaps.</p><p><strong>Spec-Version:</strong> 1.0.0 | <strong>Schema:</strong> <code>examples/state-channels/contract.json</code><strong>Fixtures:</strong> <code>examples/state-channels/fixtures/</code> | <strong>Tests:</strong> <code>conformance.test.ts</code><strong>Invariants:</strong> <a href="./../invariants">docs/invariants.md</a></p><h2 id="client-must" tabindex="-1">Client MUST <a class="header-anchor" href="#client-must" aria-label="Permalink to &quot;Client MUST&quot;">​</a></h2><ol><li>Tag all messages with <code>seq</code> (starting at 1, increment per new message, never on retry)</li><li>Track <code>expectedSeq</code> (next seq expected from server)</li><li>On receiving a message with seq &gt; expectedSeq, detect gap and request catch-up</li><li>When <code>SEQUENCE_GAP</code> is received, use <code>resumeFrom</code> to request history via <code>CATCH_UP_REQUEST</code></li></ol><h2 id="server-must" tabindex="-1">Server MUST <a class="header-anchor" href="#server-must" aria-label="Permalink to &quot;Server MUST&quot;">​</a></h2><ol><li>Assign <code>seq</code> to all outgoing messages (independent counter)</li><li>Track <code>lastClientSeq</code> (last client seq received) and <code>lastServerSeq</code> (last server seq sent to this client) per connection</li><li>If incoming client seq equals last processed seq, silently ack without side effects (idempotent deduplication)</li><li>On client seq gap detected, send <code>SEQUENCE_GAP</code> with: <ul><li><code>expectedSeq</code>: first missing client seq (diagnostic)</li><li><code>receivedSeq</code>: what client sent</li><li><code>resumeFrom</code>: first missing server seq = lastServerSeq + 1 (recovery cursor)</li></ul></li></ol><h2 id="server-should" tabindex="-1">Server SHOULD <a class="header-anchor" href="#server-should" aria-label="Permalink to &quot;Server SHOULD&quot;">​</a></h2><ol><li>Manage state history lifecycle—trim old entries or limit memory based on application needs</li></ol><h2 id="failure-modes" tabindex="-1">Failure Modes <a class="header-anchor" href="#failure-modes" aria-label="Permalink to &quot;Failure Modes&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Condition</th><th>Error</th><th>Retryable</th><th>Client Action</th></tr></thead><tbody><tr><td>Client seq gap detected</td><td>SEQUENCE_GAP</td><td>yes</td><td>request catch-up via <code>resumeFrom</code> cursor</td></tr><tr><td>Duplicate client seq</td><td>(silent ack)</td><td>yes</td><td>client retries after timeout</td></tr><tr><td>Server seq gap detected (client-side)</td><td>(detect on receive)</td><td>yes</td><td>send CATCH_UP_REQUEST from current <code>expectedSeq</code></td></tr></tbody></table><h2 id="timelines" tabindex="-1">Timelines <a class="header-anchor" href="#timelines" aria-label="Permalink to &quot;Timelines&quot;">​</a></h2><p><strong>Happy path:</strong></p>',13)),(a(),i(c,null,{default:t(()=>[l(r,{id:"mermaid-157",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20Client%0A%20%20%20%20participant%20Server%0A%20%20%20%20Client-%3E%3EServer%3A%20msg%20seq%3D1%0A%20%20%20%20Server-%3E%3EServer%3A%20apply%20locally%0A%20%20%20%20Server-%3E%3EClient%3A%20ack%20%2B%20serverSeq%3D1%0A%20%20%20%20Client-%3E%3EClient%3A%20UI%20updated%0A"})]),fallback:t(()=>[...e[0]||(e[0]=[o(" Loading... ",-1)])]),_:1})),e[3]||(e[3]=n("p",null,[n("strong",null,"Gap recovery:")],-1)),(a(),i(c,null,{default:t(()=>[l(r,{id:"mermaid-161",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20Client%0A%20%20%20%20participant%20Server%0A%20%20%20%20Client-%3E%3EServer%3A%20reconnect%0A%20%20%20%20Note%20over%20Server%3A%20detect%20gap%3Cbr%2F%3E(expect%20seq%3D2%2C%20have%20seq%3D5)%0A%20%20%20%20Server-%3E%3EClient%3A%20SEQUENCE_GAP%3Cbr%2F%3EresumeFrom%3D2%0A%20%20%20%20Client-%3E%3EServer%3A%20request%20catch-up%3Cbr%2F%3Efrom%20seq%3D2%0A%20%20%20%20Server-%3E%3EClient%3A%20seq%202%2C3%2C4%2C5%0A%20%20%20%20Client-%3E%3EClient%3A%20replay%20%26%20merge%0A"})]),fallback:t(()=>[...e[1]||(e[1]=[o(" Loading... ",-1)])]),_:1})),e[4]||(e[4]=s('<h2 id="conformance" tabindex="-1">Conformance <a class="header-anchor" href="#conformance" aria-label="Permalink to &quot;Conformance&quot;">​</a></h2><p><code>examples/state-channels/conformance.test.ts</code> currently verifies:</p><ul><li>Contract and fixture schema versions match</li><li>Fixtures are numbered sequentially</li><li>Fixtures expose the required structural fields (<code>steps</code>, <code>assertions</code>, etc.)</li></ul><p>Fixtures ship at:</p><ol><li><strong>001-initialization</strong> — Client joins, receives seq=0 snapshot</li><li><strong>002-gap-detected</strong> — Client offline, reconnects with gap, receives <code>SEQUENCE_GAP</code></li><li><strong>003-duplicate-reject</strong> — Client retries seq=5, server silently acks (no side effects)</li></ol><p>See <a href="https://github.com/kriasoft/ws-kit/tree/main/examples/state-channels/fixtures/" target="_blank" rel="noreferrer">examples/state-channels/fixtures/</a> for definitions. Executable replay tests are a future enhancement.</p>',6))])}const A=d(u,[["render",h]]);export{E as __pageData,A as default};
