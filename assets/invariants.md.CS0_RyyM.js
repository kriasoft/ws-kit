import{x as t,b as o,i,p as a}from"./chunks/framework.Dl5MHC_T.js";const h=JSON.parse('{"title":"WS-Kit Patterns â€” Invariants","description":"","frontmatter":{},"headers":[],"relativePath":"invariants.md","filePath":"invariants.md","lastUpdated":1762986796000}'),r={name:"invariants.md"};function s(n,e,l,d,c,p){return i(),o("div",null,[...e[0]||(e[0]=[a('<h1 id="ws-kit-patterns-â€”-invariants" tabindex="-1">WS-Kit Patterns â€” Invariants <a class="header-anchor" href="#ws-kit-patterns-â€”-invariants" aria-label="Permalink to â€œWS-Kit Patterns â€” Invariantsâ€">â€‹</a></h1><p>Canonical rules and names for the shipped application patterns: state channels, flow control, and delta sync.</p><h2 id="pub-sub-rules-canonical-for-all-adapters" tabindex="-1">Pub/Sub Rules (Canonical for All Adapters) <a class="header-anchor" href="#pub-sub-rules-canonical-for-all-adapters" aria-label="Permalink to â€œPub/Sub Rules (Canonical for All Adapters)â€">â€‹</a></h2><p><strong>Single Extension Point Policy</strong></p><p>Apps configure pub/sub in <strong>exactly one place</strong>: <code>usePubSub()</code> middleware.</p><table tabindex="0"><thead><tr><th>Responsibility</th><th>Where</th></tr></thead><tbody><tr><td><strong>Structural shape</strong></td><td><code>router.limits</code>: <code>topicPattern</code>, <code>maxTopicLength</code>, <code>maxTopicsPerConnection</code></td></tr><tr><td><strong>All context-aware policy</strong></td><td><code>usePubSub()</code> middleware: <code>authorizeSubscribe</code>, <code>authorizePublish</code>, <code>normalize</code>, <code>onSubscribe</code>, <code>onUnsubscribe</code></td></tr></tbody></table><p><strong>Rule</strong>: Constructor is for structural limits only. ALL authorization, normalization, and lifecycle hooks go in <code>usePubSub()</code> middleware.</p><p>See <a href="./adr/022-namespace-first-pubsub-api#_6-single-extension-point-usepubsub-as-canonical-authority">ADR-022 Â§ 6</a> for design rationale.</p><p><strong>Canonical Operation Order</strong></p><p>Every subscription operation (single or batch) follows this strict order:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Normalize â†’ Await in-flight â†’ IDEMPOTENCY CHECK â†’ Validate â†’ Authorize â†’ Limit check â†’ Adapter call â†’ Mutate â†’ Hooks</span></span></code></pre></div><p><strong>ðŸ”´ CRITICAL: Idempotency-First (Step 3)</strong></p><p>Duplicate calls return immediately with <strong>ZERO side effects</strong>:</p><ul><li>No validation</li><li>No authorization</li><li>No adapter calls</li><li>No hooks</li><li>No mutation</li></ul><p>Already-subscribed topics in batches are skipped identically. Errors only occur when state change is needed.</p><p><strong>Key Principles:</strong></p><ul><li>Adapter calls happen BEFORE local state mutation (if adapter fails, state unchanged)</li><li>Authorization always checks normalized topic (prevents TOCTOU bugs)</li><li>Hooks receive normalized topic, not raw input</li><li>Hook failures don&#39;t rollback state</li></ul><p>See <a href="./specs/pubsub#_61-canonical-operation-order-normative">docs/specs/pubsub.md#6.1</a> for complete specification and rationale.</p><h2 id="canonical-field-names" tabindex="-1">Canonical Field Names <a class="header-anchor" href="#canonical-field-names" aria-label="Permalink to â€œCanonical Field Namesâ€">â€‹</a></h2><ul><li><strong><code>seq</code></strong> â€” immutable sequence number (event ID, not revision)</li><li><strong><code>rev</code></strong> â€” snapshot revision or version number (for state snapshots, distinct from seq)</li><li><strong><code>resumeFrom</code></strong> â€” checkpoint for reconnection recovery</li><li><strong><code>policy</code></strong> â€” backpressure strategy identifier (e.g., &quot;drop-oldest&quot;, &quot;drop-new&quot;)</li><li><strong><code>retryAfterMs</code></strong> â€” server hint: milliseconds before retry is safe</li><li><strong><code>queueDepth</code></strong> â€” current queue size (pattern-specific: used in flow control)</li><li><strong><code>bufferFirstRev</code></strong> â€” oldest revision still available in the operation buffer (pattern-specific: used in delta sync)</li></ul><p>Each pattern may introduce additional helper fields to support error recovery. For example, state channels uses:</p><ul><li><code>expectedSeq</code> (diagnostic: first missing client seq)</li><li><code>receivedSeq</code> (diagnostic: what client sent)</li><li><code>resumeFrom</code> (recovery cursor: first missing server seq)</li></ul><p>Refer to pattern documentation for full field lists and semantics.</p><h2 id="do" tabindex="-1">DO <a class="header-anchor" href="#do" aria-label="Permalink to â€œDOâ€">â€‹</a></h2><ul><li>Use <code>seq</code> as event identity; never increment on retry</li><li>Validate <code>seq</code> ordering server-side before applying</li><li>Provide fixtures for all documented scenarios (happy path plus at least one failure)</li><li>Version schemas independently of WS-Kit releases (<code>1.0.0</code> format)</li><li>Emit <code>retryAfterMs</code> hints instead of hard-coded retry delays</li></ul><h2 id="don-t" tabindex="-1">DON&#39;T <a class="header-anchor" href="#don-t" aria-label="Permalink to â€œDON&#39;Tâ€">â€‹</a></h2><ul><li>Reuse <code>id</code> for sequencing (ambiguous with message ID)</li><li>Treat <code>seq</code> as revision (different semantics)</li><li>Assume idempotent retry without explicit <code>seq</code> dedup</li><li>Hard-code error recovery logic (send retry hints instead)</li><li>Mix schema versions in test fixtures</li><li>Bypass schema validation before payload processing</li></ul><h2 id="error-codes" tabindex="-1">Error Codes <a class="header-anchor" href="#error-codes" aria-label="Permalink to â€œError Codesâ€">â€‹</a></h2><p>Canonical errors implemented across patterns.</p><table tabindex="0"><thead><tr><th>Code</th><th>Pattern</th><th>Meaning</th><th>Retryable</th><th>Hint</th></tr></thead><tbody><tr><td><code>RESOURCE_EXHAUSTED</code></td><td>flow-control</td><td>Queue full / backpressure</td><td>yes</td><td>send <code>retryAfterMs</code> in response</td></tr><tr><td><code>SEQUENCE_GAP</code></td><td>state-channels</td><td>Received seq &gt; expected</td><td>yes</td><td>request catch-up from gap point</td></tr><tr><td><code>REVISION_GAP</code></td><td>delta-sync</td><td>Client rev too far behind</td><td>yes</td><td>send snapshot; include <code>bufferFirstRev</code></td></tr></tbody></table><h2 id="conformance" tabindex="-1">Conformance <a class="header-anchor" href="#conformance" aria-label="Permalink to â€œConformanceâ€">â€‹</a></h2><p>All fixtures MUST:</p><ul><li>Declare <code>schemaVersion</code> and <code>fixtureVersion</code></li><li>Include an <code>assertions</code> array (structure validated; runtime content optional)</li><li>Be sorted by number (e.g., <code>001-*.json</code>, <code>002-*.json</code>)</li></ul><p>Collectively, fixtures for a pattern SHOULD cover:</p><ul><li>Happy path / normal operation (e.g., <code>001-*.json</code>)</li><li>At least one documented failure scenario (e.g., <code>002-*.json</code>, <code>003-*.json</code>)</li></ul>',35)])])}const f=t(r,[["render",s]]);export{h as __pageData,f as default};
