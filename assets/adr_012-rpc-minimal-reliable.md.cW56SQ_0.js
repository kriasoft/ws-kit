import{x as i,a as s,f as r,p as a}from"./chunks/framework.DdttWuXo.js";const g=JSON.parse('{"title":"ADR-012: Minimal Reliable RPC for WebSocket Routing","description":"","frontmatter":{},"headers":[],"relativePath":"adr/012-rpc-minimal-reliable.md","filePath":"adr/012-rpc-minimal-reliable.md","lastUpdated":1763145939000}'),t={name:"adr/012-rpc-minimal-reliable.md"};function o(n,e,l,c,d,p){return r(),s("div",null,[...e[0]||(e[0]=[a(`<h1 id="adr-012-minimal-reliable-rpc-for-websocket-routing" tabindex="-1">ADR-012: Minimal Reliable RPC for WebSocket Routing <a class="header-anchor" href="#adr-012-minimal-reliable-rpc-for-websocket-routing" aria-label="Permalink to “ADR-012: Minimal Reliable RPC for WebSocket Routing”">​</a></h1><h2 id="metadata" tabindex="-1">Metadata <a class="header-anchor" href="#metadata" aria-label="Permalink to “Metadata”">​</a></h2><ul><li><strong>Date</strong>: 2025-10-30</li><li><strong>Status</strong>: Accepted</li><li><strong>Tags</strong>: RPC, reliability, request-response, type-safety</li></ul><h2 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to “Context”">​</a></h2><p>WebSocket-based request-response patterns (RPC) are common in real-time applications. WS-Kit already provides basic RPC via schema-bound pairs (<code>rpc()</code> helper), but lacked production-hardening features critical for reliability:</p><ul><li><strong>No cancellation</strong>: Long-running queries couldn&#39;t be aborted, wasting server resources.</li><li><strong>No reconnection policy</strong>: In-flight RPCs orphaned on disconnect, with no safe resend mechanism.</li><li><strong>No backpressure</strong>: Unbounded buffering could exhaust memory under high throughput.</li><li><strong>Weak error contract</strong>: Clients couldn&#39;t distinguish between retryable and fatal errors.</li><li><strong>No deadline propagation</strong>: Server couldn&#39;t short-circuit work past timeout.</li></ul><p>These gaps made RPC feel &quot;toy-grade&quot; for production, despite strong type inference.</p><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to “Decision”">​</a></h2><p>Implement minimal, composable RPC features focused on reliability without bloating the core:</p><h3 id="_1-internal-abort-protocol-ws-abort" tabindex="-1">1. <strong>Internal Abort Protocol</strong> (<code>$ws:abort</code>) <a class="header-anchor" href="#_1-internal-abort-protocol-ws-abort" aria-label="Permalink to “1. Internal Abort Protocol ($ws:abort)”">​</a></h3><ul><li>Client sends internal <code>$ws:abort</code> control frame when <code>AbortSignal</code> fires or socket closes.</li><li>Server triggers <code>ctx.onCancel()</code> callbacks for cleanup (cancel queries, release locks, etc.).</li><li>No new public API; handled internally by router.</li></ul><h3 id="_2-server-derived-deadlines" tabindex="-1">2. <strong>Server-Derived Deadlines</strong> <a class="header-anchor" href="#_2-server-derived-deadlines" aria-label="Permalink to “2. Server-Derived Deadlines”">​</a></h3><ul><li>Client sends <code>meta.timeoutMs</code> (optional); server computes <code>ctx.deadline = receivedAt + timeoutMs</code>.</li><li>Prevent clock-skew exploits; handlers check <code>ctx.timeRemaining()</code> for short-circuit logic.</li><li>No automatic termination; advisory only.</li></ul><h3 id="_3-one-shot-reply-guard" tabindex="-1">3. <strong>One-Shot Reply Guard</strong> <a class="header-anchor" href="#_3-one-shot-reply-guard" aria-label="Permalink to “3. One-Shot Reply Guard”">​</a></h3><ul><li>After <code>ctx.reply()</code> or <code>ctx.error()</code>, further sends are no-ops with debug log.</li><li>Prevents accidental double-sends or mixed terminals (reply→error).</li><li>Simplifies handler logic; no explicit &quot;replied&quot; flags needed.</li></ul><h3 id="_4-structured-rpc-error-contract" tabindex="-1">4. <strong>Structured RPC Error Contract</strong> <a class="header-anchor" href="#_4-structured-rpc-error-contract" aria-label="Permalink to “4. Structured RPC Error Contract”">​</a></h3><ul><li>RPC errors sent as <code>RPC_ERROR</code> wire format with <code>code</code>, <code>message</code>, <code>details</code>, <code>retryable</code>, <code>retryAfterMs</code>.</li><li>Client maps to <code>RpcError</code> exception with typed <code>code</code> field.</li><li>Validation failures send <code>RPC_ERROR{VALIDATION}</code>, socket stays open (not closed).</li></ul><h3 id="_5-backpressure-fail-fast-policy" tabindex="-1">5. <strong>Backpressure: Fail-Fast Policy</strong> <a class="header-anchor" href="#_5-backpressure-fail-fast-policy" aria-label="Permalink to “5. Backpressure: Fail-Fast Policy”">​</a></h3><ul><li>Configurable <code>maxQueuedBytesPerSocket</code> (default 1MB).</li><li>If buffered exceeds threshold during RPC reply, send <code>RPC_ERROR{RESOURCE_EXHAUSTED,retryable:true, retryAfterMs:100}</code> and abort RPC.</li><li>No unbounded queuing; predictable behavior under load.</li></ul><h3 id="_6-progress-messages-streaming-foundation" tabindex="-1">6. <strong>Progress Messages (Streaming Foundation)</strong> <a class="header-anchor" href="#_6-progress-messages-streaming-foundation" aria-label="Permalink to “6. Progress Messages (Streaming Foundation)”">​</a></h3><ul><li><code>ctx.send()</code> for progress auto-copies <code>correlationId</code> from request.</li><li>Allows multi-message RPC responses without new primitive.</li><li>Foundation for future streaming enhancements.</li></ul><h3 id="_7-rpc-detection-context-flags" tabindex="-1">7. <strong>RPC Detection &amp; Context Flags</strong> <a class="header-anchor" href="#_7-rpc-detection-context-flags" aria-label="Permalink to “7. RPC Detection &amp; Context Flags”">​</a></h3><ul><li>Router auto-detects RPC (schema has <code>.response</code> property).</li><li><code>ctx.isRpc</code> flag for middleware to apply RPC-specific logic (auth, rate-limit, idempotency).</li><li><code>ctx.onCancel()</code> only available for RPC messages.</li></ul><h3 id="_8-reserved-control-prefix-ws" tabindex="-1">8. <strong>Reserved Control Prefix</strong> (<code>$ws:</code>) <a class="header-anchor" href="#_8-reserved-control-prefix-ws" aria-label="Permalink to “8. Reserved Control Prefix ($ws:)”">​</a></h3><ul><li>User message types cannot start with <code>$ws:</code> (enforced at schema registration).</li><li>Internal control frames (<code>$ws:abort</code>, <code>$ws:ping</code>, etc.) filtered before validation.</li><li>Prevents user-defined message type from colliding with protocol frames.</li></ul><h2 id="alternatives-considered" tabindex="-1">Alternatives Considered <a class="header-anchor" href="#alternatives-considered" aria-label="Permalink to “Alternatives Considered”">​</a></h2><ol><li><strong>Expose <code>ctx.progress()</code> primitive</strong>: Adds API surface; reusing <code>ctx.send()</code> + auto-correlation is simpler.</li><li><strong>RPC-specific hooks</strong> (<code>onAuth</code>, <code>onBefore</code>, <code>onAfter</code>): Reuse existing middleware pattern with <code>ctx.isRpc</code> flag—less API growth.</li><li><strong>Automatic RPC error retry</strong>: Moves policy to core; better as pattern/middleware with per-app retry logic.</li><li><strong>Soft deadline enforcement</strong>: Server auto-closes RPCs past deadline; may interrupt cleanup; timeouts are client-enforced instead.</li><li><strong>Public abort control messages</strong>: Expose <code>$ws:abort</code> to applications; simpler to keep internal—don&#39;t expose protocol internals.</li></ol><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to “Consequences”">​</a></h2><h3 id="benefits" tabindex="-1">Benefits <a class="header-anchor" href="#benefits" aria-label="Permalink to “Benefits”">​</a></h3><ul><li><strong>Reliability</strong>: Abort, backpressure, and deadlines prevent resource leaks and cascading failures.</li><li><strong>Type Safety</strong>: Structured errors + typed <code>code</code> field integrate with client exception handling.</li><li><strong>Composability</strong>: One-shot guard and isRpc flag enable middleware (auth, idempotency, rate-limit) without core bloat.</li><li><strong>Non-breaking</strong>: Existing non-RPC routing unaffected; RPC is opt-in via <code>rpc()</code> schema.</li><li><strong>Performance</strong>: Minimal overhead; RPC state tracked per-correlation (O(1) lookups).</li></ul><h3 id="risks-trade-offs" tabindex="-1">Risks / Trade-offs <a class="header-anchor" href="#risks-trade-offs" aria-label="Permalink to “Risks / Trade-offs”">​</a></h3><ul><li><strong>Complexity</strong>: One-shot tracking adds modest code (offset by fewer handler bugs).</li><li><strong>Control Protocol</strong>: <code>$ws:</code> prefix reserved; users cannot define messages starting with it (documented, runtime-enforced).</li><li><strong>Deadline Semantics</strong>: Client-supplied <code>timeoutMs</code> used as hint; server derives deadline. Clock skew could cause mis-calculation (mitigated by server-side derivation; documented).</li></ul><h3 id="maintenance" tabindex="-1">Maintenance <a class="header-anchor" href="#maintenance" aria-label="Permalink to “Maintenance”">​</a></h3><ul><li>RPC state map must be cleaned up on disconnect (done via <code>handleClose()</code>).</li><li>New test suite covers abort, one-shot, deadline, backpressure, validation (conformance tests prevent regressions).</li></ul><h2 id="implementation-ctx-error-one-shot-guard" tabindex="-1">Implementation: ctx.error() One-Shot Guard <a class="header-anchor" href="#implementation-ctx-error-one-shot-guard" aria-label="Permalink to “Implementation: ctx.error() One-Shot Guard”">​</a></h2><p><code>ctx.error(code, message, details, opts)</code> is a terminal method (like <code>ctx.reply()</code>) enforced by the same RPC state tracking: the first call to either <code>.reply()</code> or <code>.error()</code> marks the RPC as responded; further calls become no-ops (logged in dev mode). This prevents accidental double-responses and unifies error/success paths under one reliability model.</p><p><strong>Wire Format</strong>: Errors are sent as <code>RPC_ERROR</code> frames with structured <code>{code, message, details, retryable, retryAfterMs}</code> to allow clients to distinguish retryable failures (e.g., &quot;RESOURCE_EXHAUSTED&quot;, backoff advised) from fatal ones (e.g., &quot;NOT_FOUND&quot;, don&#39;t retry).</p><p><strong>Example</strong>:</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rpc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GetUserMsg, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> user</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> db.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx.payload.id);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">user) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Terminal: RPC ends here; any further .reply() or .error() ignored</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;NOT_FOUND&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;User not found&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { id: ctx.payload.id });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Success path: symmetric to error path</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ id: user.id, name: user.name });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><hr><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to “References”">​</a></h2><ul><li><strong>RPC Helper</strong>: <code>packages/zod/src/schema.ts:rpc()</code></li><li><strong>Router RPC Impl</strong>: <code>packages/core/src/router.ts</code> — <code>rpcStates</code> map, <code>getRpcState()</code>, <code>cancelRpc()</code>, etc.</li><li><strong>Types</strong>: <code>packages/core/src/types.ts</code> — <code>RpcAbortWire</code>, <code>RpcErrorWire</code>, <code>ctx.isRpc</code>, <code>ctx.onCancel()</code></li><li><strong>Constants</strong>: <code>packages/core/src/constants.ts</code> — <code>RESERVED_CONTROL_PREFIX</code>, backpressure/timeout defaults</li><li><strong>Specs</strong>: <ul><li><code>docs/specs/router.md#RPC-Invariants</code> (unicast, one-shot, validation→RPC_ERROR)</li><li><code>docs/specs/schema.md#Meta-Fields</code> (timeoutMs, idempotencyKey, control prefix rule)</li></ul></li><li><strong>Future work</strong>: Client abort signal support, reconnect policy, idempotency middleware pattern.</li></ul>`,42)])])}const u=i(t,[["render",o]]);export{g as __pageData,u as default};
