import{x as t,b as s,i as a,p as i}from"./chunks/framework.Dl5MHC_T.js";const g=JSON.parse('{"title":"State Channels Application Pattern","description":"","frontmatter":{},"headers":[],"relativePath":"patterns/state-channels.md","filePath":"patterns/state-channels.md","lastUpdated":1762079697000}'),n={name:"patterns/state-channels.md"};function r(l,e,c,o,d,p){return a(),s("div",null,[...e[0]||(e[0]=[i(`<h1 id="state-channels-application-pattern" tabindex="-1">State Channels Application Pattern <a class="header-anchor" href="#state-channels-application-pattern" aria-label="Permalink to “State Channels Application Pattern”">​</a></h1><p>Reliable FIFO state updates with client sequence tracking and recovery from gaps.</p><p><strong>Spec-Version:</strong> 1.0.0 | <strong>Schema:</strong> <code>examples/state-channels/contract.json</code><strong>Fixtures:</strong> <code>examples/state-channels/fixtures/</code> | <strong>Tests:</strong> <code>conformance.test.ts</code><strong>Invariants:</strong> <a href="./../invariants">docs/invariants.md</a></p><h2 id="client-must" tabindex="-1">Client MUST <a class="header-anchor" href="#client-must" aria-label="Permalink to “Client MUST”">​</a></h2><ol><li>Tag all messages with <code>seq</code> (starting at 1, increment per new message, never on retry)</li><li>Track <code>expectedSeq</code> (next seq expected from server)</li><li>On receiving a message with seq &gt; expectedSeq, detect gap and request catch-up</li><li>When <code>SEQUENCE_GAP</code> is received, use <code>resumeFrom</code> to request history via <code>CATCH_UP_REQUEST</code></li></ol><h2 id="server-must" tabindex="-1">Server MUST <a class="header-anchor" href="#server-must" aria-label="Permalink to “Server MUST”">​</a></h2><ol><li>Assign <code>seq</code> to all outgoing messages (independent counter)</li><li>Track <code>lastClientSeq</code> (last client seq received) and <code>lastServerSeq</code> (last server seq sent to this client) per connection</li><li>If incoming client seq equals last processed seq, silently ack without side effects (idempotent deduplication)</li><li>On client seq gap detected, send <code>SEQUENCE_GAP</code> with: <ul><li><code>expectedSeq</code>: first missing client seq (diagnostic)</li><li><code>receivedSeq</code>: what client sent</li><li><code>resumeFrom</code>: first missing server seq = lastServerSeq + 1 (recovery cursor)</li></ul></li></ol><h2 id="server-should" tabindex="-1">Server SHOULD <a class="header-anchor" href="#server-should" aria-label="Permalink to “Server SHOULD”">​</a></h2><ol><li>Manage state history lifecycle—trim old entries or limit memory based on application needs</li></ol><h2 id="failure-modes" tabindex="-1">Failure Modes <a class="header-anchor" href="#failure-modes" aria-label="Permalink to “Failure Modes”">​</a></h2><table tabindex="0"><thead><tr><th>Condition</th><th>Error</th><th>Retryable</th><th>Client Action</th></tr></thead><tbody><tr><td>Client seq gap detected</td><td>SEQUENCE_GAP</td><td>yes</td><td>request catch-up via <code>resumeFrom</code> cursor</td></tr><tr><td>Duplicate client seq</td><td>(silent ack)</td><td>yes</td><td>client retries after timeout</td></tr><tr><td>Server seq gap detected (client-side)</td><td>(detect on receive)</td><td>yes</td><td>send CATCH_UP_REQUEST from current <code>expectedSeq</code></td></tr></tbody></table><h2 id="timelines" tabindex="-1">Timelines <a class="header-anchor" href="#timelines" aria-label="Permalink to “Timelines”">​</a></h2><p><strong>Happy path:</strong></p><div class="language-mermaid"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sequenceDiagram</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    participant Client</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    participant Server</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;Server: msg seq=1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Server-&gt;&gt;Server: apply locally</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Server-&gt;&gt;Client: ack + serverSeq=1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;Client: UI updated</span></span></code></pre></div><p><strong>Gap recovery:</strong></p><div class="language-mermaid"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sequenceDiagram</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    participant Client</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    participant Server</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;Server: reconnect</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Note over Server: detect gap&lt;br/&gt;(expect seq=2, have seq=5)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Server-&gt;&gt;Client: SEQUENCE_GAP&lt;br/&gt;resumeFrom=2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;Server: request catch-up&lt;br/&gt;from seq=2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Server-&gt;&gt;Client: seq 2,3,4,5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;Client: replay &amp; merge</span></span></code></pre></div><h2 id="conformance" tabindex="-1">Conformance <a class="header-anchor" href="#conformance" aria-label="Permalink to “Conformance”">​</a></h2><p><code>examples/state-channels/conformance.test.ts</code> currently verifies:</p><ul><li>Contract and fixture schema versions match</li><li>Fixtures are numbered sequentially</li><li>Fixtures expose the required structural fields (<code>steps</code>, <code>assertions</code>, etc.)</li></ul><p>Fixtures ship at:</p><ol><li><strong>001-initialization</strong> — Client joins, receives seq=0 snapshot</li><li><strong>002-gap-detected</strong> — Client offline, reconnects with gap, receives <code>SEQUENCE_GAP</code></li><li><strong>003-duplicate-reject</strong> — Client retries seq=5, server silently acks (no side effects)</li></ol><p>See <a href="https://github.com/kriasoft/ws-kit/tree/main/examples/state-channels/fixtures/" target="_blank" rel="noreferrer">examples/state-channels/fixtures/</a> for definitions. Executable replay tests are a future enhancement.</p>`,22)])])}const E=t(n,[["render",r]]);export{g as __pageData,E as default};
