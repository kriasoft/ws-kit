import{_ as o,c as r,o as t,ag as a}from"./chunks/framework.DbtdwhWj.js";const g=JSON.parse('{"title":"ADR-012: Minimal Reliable RPC for WebSocket Routing","description":"","frontmatter":{},"headers":[],"relativePath":"adr/012-rpc-minimal-reliable.md","filePath":"adr/012-rpc-minimal-reliable.md","lastUpdated":1762007311000}'),i={name:"adr/012-rpc-minimal-reliable.md"};function s(n,e,l,c,d,u){return t(),r("div",null,[...e[0]||(e[0]=[a('<h1 id="adr-012-minimal-reliable-rpc-for-websocket-routing" tabindex="-1">ADR-012: Minimal Reliable RPC for WebSocket Routing <a class="header-anchor" href="#adr-012-minimal-reliable-rpc-for-websocket-routing" aria-label="Permalink to &quot;ADR-012: Minimal Reliable RPC for WebSocket Routing&quot;">​</a></h1><h2 id="metadata" tabindex="-1">Metadata <a class="header-anchor" href="#metadata" aria-label="Permalink to &quot;Metadata&quot;">​</a></h2><ul><li><strong>Date</strong>: 2025-10-30</li><li><strong>Status</strong>: Accepted</li><li><strong>Tags</strong>: RPC, reliability, request-response, type-safety</li></ul><h2 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;Context&quot;">​</a></h2><p>WebSocket-based request-response patterns (RPC) are common in real-time applications. WS-Kit already provides basic RPC via schema-bound pairs (<code>rpc()</code> helper), but lacked production-hardening features critical for reliability:</p><ul><li><strong>No cancellation</strong>: Long-running queries couldn&#39;t be aborted, wasting server resources.</li><li><strong>No reconnection policy</strong>: In-flight RPCs orphaned on disconnect, with no safe resend mechanism.</li><li><strong>No backpressure</strong>: Unbounded buffering could exhaust memory under high throughput.</li><li><strong>Weak error contract</strong>: Clients couldn&#39;t distinguish between retryable and fatal errors.</li><li><strong>No deadline propagation</strong>: Server couldn&#39;t short-circuit work past timeout.</li></ul><p>These gaps made RPC feel &quot;toy-grade&quot; for production, despite strong type inference.</p><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to &quot;Decision&quot;">​</a></h2><p>Implement minimal, composable RPC features focused on reliability without bloating the core:</p><h3 id="_1-internal-abort-protocol-ws-abort" tabindex="-1">1. <strong>Internal Abort Protocol</strong> (<code>$ws:abort</code>) <a class="header-anchor" href="#_1-internal-abort-protocol-ws-abort" aria-label="Permalink to &quot;1. **Internal Abort Protocol** (`$ws:abort`)&quot;">​</a></h3><ul><li>Client sends internal <code>$ws:abort</code> control frame when <code>AbortSignal</code> fires or socket closes.</li><li>Server triggers <code>ctx.onCancel()</code> callbacks for cleanup (cancel queries, release locks, etc.).</li><li>No new public API; handled internally by router.</li></ul><h3 id="_2-server-derived-deadlines" tabindex="-1">2. <strong>Server-Derived Deadlines</strong> <a class="header-anchor" href="#_2-server-derived-deadlines" aria-label="Permalink to &quot;2. **Server-Derived Deadlines**&quot;">​</a></h3><ul><li>Client sends <code>meta.timeoutMs</code> (optional); server computes <code>ctx.deadline = receivedAt + timeoutMs</code>.</li><li>Prevent clock-skew exploits; handlers check <code>ctx.timeRemaining()</code> for short-circuit logic.</li><li>No automatic termination; advisory only.</li></ul><h3 id="_3-one-shot-reply-guard" tabindex="-1">3. <strong>One-Shot Reply Guard</strong> <a class="header-anchor" href="#_3-one-shot-reply-guard" aria-label="Permalink to &quot;3. **One-Shot Reply Guard**&quot;">​</a></h3><ul><li>After <code>ctx.send()</code> or <code>ctx.error()</code>, further sends are no-ops with debug log.</li><li>Prevents accidental double-sends or mixed terminals (reply→error).</li><li>Simplifies handler logic; no explicit &quot;replied&quot; flags needed.</li></ul><h3 id="_4-structured-rpc-error-contract" tabindex="-1">4. <strong>Structured RPC Error Contract</strong> <a class="header-anchor" href="#_4-structured-rpc-error-contract" aria-label="Permalink to &quot;4. **Structured RPC Error Contract**&quot;">​</a></h3><ul><li>RPC errors sent as <code>RPC_ERROR</code> wire format with <code>code</code>, <code>message</code>, <code>details</code>, <code>retryable</code>, <code>retryAfterMs</code>.</li><li>Client maps to <code>RpcError</code> exception with typed <code>code</code> field.</li><li>Validation failures send <code>RPC_ERROR{VALIDATION}</code>, socket stays open (not closed).</li></ul><h3 id="_5-backpressure-fail-fast-policy" tabindex="-1">5. <strong>Backpressure: Fail-Fast Policy</strong> <a class="header-anchor" href="#_5-backpressure-fail-fast-policy" aria-label="Permalink to &quot;5. **Backpressure: Fail-Fast Policy**&quot;">​</a></h3><ul><li>Configurable <code>maxQueuedBytesPerSocket</code> (default 1MB).</li><li>If buffered exceeds threshold during RPC reply, send <code>RPC_ERROR{RESOURCE_EXHAUSTED,retryable:true, retryAfterMs:100}</code> and abort RPC.</li><li>No unbounded queuing; predictable behavior under load.</li></ul><h3 id="_6-progress-messages-streaming-foundation" tabindex="-1">6. <strong>Progress Messages (Streaming Foundation)</strong> <a class="header-anchor" href="#_6-progress-messages-streaming-foundation" aria-label="Permalink to &quot;6. **Progress Messages (Streaming Foundation)**&quot;">​</a></h3><ul><li><code>ctx.send()</code> for progress auto-copies <code>correlationId</code> from request.</li><li>Allows multi-message RPC responses without new primitive.</li><li>Foundation for future streaming enhancements.</li></ul><h3 id="_7-rpc-detection-context-flags" tabindex="-1">7. <strong>RPC Detection &amp; Context Flags</strong> <a class="header-anchor" href="#_7-rpc-detection-context-flags" aria-label="Permalink to &quot;7. **RPC Detection &amp; Context Flags**&quot;">​</a></h3><ul><li>Router auto-detects RPC (schema has <code>.response</code> property).</li><li><code>ctx.isRpc</code> flag for middleware to apply RPC-specific logic (auth, rate-limit, idempotency).</li><li><code>ctx.onCancel()</code> only available for RPC messages.</li></ul><h3 id="_8-reserved-control-prefix-ws" tabindex="-1">8. <strong>Reserved Control Prefix</strong> (<code>$ws:</code>) <a class="header-anchor" href="#_8-reserved-control-prefix-ws" aria-label="Permalink to &quot;8. **Reserved Control Prefix** (`$ws:`)&quot;">​</a></h3><ul><li>User message types cannot start with <code>$ws:</code> (enforced at schema registration).</li><li>Internal control frames (<code>$ws:abort</code>, <code>$ws:ping</code>, etc.) filtered before validation.</li><li>Prevents user-defined message type from colliding with protocol frames.</li></ul><h2 id="alternatives-considered" tabindex="-1">Alternatives Considered <a class="header-anchor" href="#alternatives-considered" aria-label="Permalink to &quot;Alternatives Considered&quot;">​</a></h2><ol><li><strong>Expose <code>ctx.progress()</code> primitive</strong>: Adds API surface; reusing <code>ctx.send()</code> + auto-correlation is simpler.</li><li><strong>RPC-specific hooks</strong> (<code>onAuth</code>, <code>onBefore</code>, <code>onAfter</code>): Reuse existing middleware pattern with <code>ctx.isRpc</code> flag—less API growth.</li><li><strong>Automatic RPC error retry</strong>: Moves policy to core; better as pattern/middleware with per-app retry logic.</li><li><strong>Soft deadline enforcement</strong>: Server auto-closes RPCs past deadline; may interrupt cleanup; timeouts are client-enforced instead.</li><li><strong>Public abort control messages</strong>: Expose <code>$ws:abort</code> to applications; simpler to keep internal—don&#39;t expose protocol internals.</li></ol><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to &quot;Consequences&quot;">​</a></h2><h3 id="benefits" tabindex="-1">Benefits <a class="header-anchor" href="#benefits" aria-label="Permalink to &quot;Benefits&quot;">​</a></h3><ul><li><strong>Reliability</strong>: Abort, backpressure, and deadlines prevent resource leaks and cascading failures.</li><li><strong>Type Safety</strong>: Structured errors + typed <code>code</code> field integrate with client exception handling.</li><li><strong>Composability</strong>: One-shot guard and isRpc flag enable middleware (auth, idempotency, rate-limit) without core bloat.</li><li><strong>Non-breaking</strong>: Existing non-RPC routing unaffected; RPC is opt-in via <code>rpc()</code> schema.</li><li><strong>Performance</strong>: Minimal overhead; RPC state tracked per-correlation (O(1) lookups).</li></ul><h3 id="risks-trade-offs" tabindex="-1">Risks / Trade-offs <a class="header-anchor" href="#risks-trade-offs" aria-label="Permalink to &quot;Risks / Trade-offs&quot;">​</a></h3><ul><li><strong>Complexity</strong>: One-shot tracking adds modest code (offset by fewer handler bugs).</li><li><strong>Control Protocol</strong>: <code>$ws:</code> prefix reserved; users cannot define messages starting with it (documented, runtime-enforced).</li><li><strong>Deadline Semantics</strong>: Client-supplied <code>timeoutMs</code> used as hint; server derives deadline. Clock skew could cause mis-calculation (mitigated by server-side derivation; documented).</li></ul><h3 id="maintenance" tabindex="-1">Maintenance <a class="header-anchor" href="#maintenance" aria-label="Permalink to &quot;Maintenance&quot;">​</a></h3><ul><li>RPC state map must be cleaned up on disconnect (done via <code>handleClose()</code>).</li><li>New test suite covers abort, one-shot, deadline, backpressure, validation (conformance tests prevent regressions).</li></ul><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><ul><li><strong>RPC Helper</strong>: <code>packages/zod/src/schema.ts:rpc()</code></li><li><strong>Router RPC Impl</strong>: <code>packages/core/src/router.ts</code> — <code>rpcStates</code> map, <code>getRpcState()</code>, <code>cancelRpc()</code>, etc.</li><li><strong>Types</strong>: <code>packages/core/src/types.ts</code> — <code>RpcAbortWire</code>, <code>RpcErrorWire</code>, <code>ctx.isRpc</code>, <code>ctx.onCancel()</code></li><li><strong>Constants</strong>: <code>packages/core/src/constants.ts</code> — <code>RESERVED_CONTROL_PREFIX</code>, backpressure/timeout defaults</li><li><strong>Specs</strong>: <ul><li><code>docs/specs/router.md#RPC-Invariants</code> (unicast, one-shot, validation→RPC_ERROR)</li><li><code>docs/specs/schema.md#Meta-Fields</code> (timeoutMs, idempotencyKey, control prefix rule)</li></ul></li><li><strong>Future work</strong>: Client abort signal support, reconnect policy, idempotency middleware pattern.</li></ul>',36)])])}const h=o(i,[["render",s]]);export{g as __pageData,h as default};
