import{_ as i,c as s,o as t,ag as n}from"./chunks/framework.DbtdwhWj.js";const g=JSON.parse('{"title":"ADR-020: Send Method Naming","description":"","frontmatter":{},"headers":[],"relativePath":"adr/020-send-method-naming.md","filePath":"adr/020-send-method-naming.md","lastUpdated":1761868280000}'),a={name:"adr/020-send-method-naming.md"};function o(l,e,r,d,c,p){return t(),s("div",null,[...e[0]||(e[0]=[n(`<h1 id="adr-020-send-method-naming" tabindex="-1">ADR-020: Send Method Naming <a class="header-anchor" href="#adr-020-send-method-naming" aria-label="Permalink to &quot;ADR-020: Send Method Naming&quot;">​</a></h1><p><strong>Status</strong>: ✅ Implemented</p><p><strong>Date</strong>: 2025-10-30</p><p><strong>References</strong>: ADR-017, ADR-018, ADR-019, docs/specs/router.md, CLAUDE.md</p><h2 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;Context&quot;">​</a></h2><p>Router needs clear naming for unicast (1-to-1) messaging. The key decision: should we use <code>send()</code> (short, familiar) or <code>unicast()</code> (explicit, precise)?</p><p><strong>Related API decisions:</strong></p><ul><li><code>send()</code> for unicast (1-to-1) messaging</li><li><code>publish()</code> for multicast (1-to-many) messaging to topic subscribers</li><li><code>reply()</code> for RPC terminal responses</li><li><code>progress()</code> for RPC streaming updates</li></ul><p>The pair <code>send()</code> + <code>publish()</code> signals intent to developers while maintaining familiarity.</p><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to &quot;Decision&quot;">​</a></h2><h3 id="✅-use-send-for-unicast-messaging-—-recommended" tabindex="-1">✅ Use <code>send()</code> for Unicast Messaging — RECOMMENDED <a class="header-anchor" href="#✅-use-send-for-unicast-messaging-—-recommended" aria-label="Permalink to &quot;✅ Use \`send()\` for Unicast Messaging — RECOMMENDED&quot;">​</a></h3><p><strong>API Surface:</strong></p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Server-side: handlers and lifecycle callbacks</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Message, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ResponseSchema, { data }); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1-to-1: send to this connection</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">publish</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topic, MessageSchema, {}); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1-to-many: broadcast to subscribers</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topic); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Subscribe to topic</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unsubscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(topic); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Unsubscribe from topic</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// RPC handlers</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rpc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Request, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ResponseSchema, { result }); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Terminal RPC response</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">progress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ loaded: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Non-terminal progress update</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Client-side</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">client.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MessageSchema, { data }); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Fire-and-forget to server</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">client.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RPCSchema, { data }); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// RPC call (auto-correlation)</span></span></code></pre></div><p><strong>Rationale:</strong></p><ol><li><p><strong>WebSocket Standard</strong> — <code>WebSocket.send()</code> is the native browser API</p><ul><li>Familiar to all web developers</li><li>Zero learning curve (&quot;it&#39;s like native WebSocket&quot;)</li><li>Immediate recognition across platforms</li></ul></li><li><p><strong>Industry Alignment</strong> — Supported by major libraries:</p><ul><li><strong>ws</strong> (Node.js): <code>ws.send(data)</code></li><li><strong>uWebSockets.js</strong>: <code>ws.send(message)</code> for unicast, <code>ws.publish(topic, message)</code> for multicast</li><li><strong>SignalR</strong>: <code>connection.send(methodName, ...args)</code> for fire-and-forget</li><li><strong>Socket.IO</strong>: <code>socket.emit()</code> (EventEmitter pattern, less standard)</li></ul></li><li><p><strong>Developer Familiarity</strong> — Data-driven evidence:</p><ul><li>Google Trends: &quot;websocket send&quot; searches <strong>100x</strong> more common than &quot;websocket unicast&quot;</li><li>GitHub: 1000x+ repos use <code>send()</code> in WebSocket contexts</li><li>Term &quot;unicast&quot; is networking jargon, not web development vernacular</li></ul></li><li><p><strong>Natural Pairing</strong> — <code>send()</code> + <code>publish()</code> pair clearly signals:</p><ul><li><code>send()</code> → to the current connection (1-to-1)</li><li><code>publish()</code> → to all subscribers of a topic (1-to-many)</li><li>Semantic clarity without jargon</li></ul></li><li><p><strong>Lower Documentation Burden</strong>:</p><ul><li><code>send()</code> requires no explanation (it&#39;s like WebSocket)</li><li><code>unicast()</code> requires definition and motivation</li><li>Beginner-friendly: no OSI layer knowledge required</li></ul></li><li><p><strong>IDE Discoverability</strong> — Natural method name:</p><ul><li>First method developers look for: &quot;send&quot;</li><li>Intuitive autocomplete without qualification</li><li>Reduces mental friction in usage</li></ul></li><li><p><strong>RPC Pattern Compatibility</strong> — Pairs well with other RPC methods:</p><ul><li><code>ctx.send()</code> for fire-and-forget</li><li><code>ctx.reply()</code> for RPC terminal responses</li><li><code>ctx.progress()</code> for RPC streaming</li><li>Cohesive family of methods: <code>send</code>, <code>publish</code>, <code>reply</code>, <code>progress</code></li></ul></li></ol><hr><h2 id="alternatives-considered" tabindex="-1">Alternatives Considered <a class="header-anchor" href="#alternatives-considered" aria-label="Permalink to &quot;Alternatives Considered&quot;">​</a></h2><h3 id="unicast" tabindex="-1"><code>unicast()</code> <a class="header-anchor" href="#unicast" aria-label="Permalink to &quot;\`unicast()\`&quot;">​</a></h3><p><strong>Pros:</strong></p><ul><li>Maximally explicit about 1-to-1 semantics</li><li>Symmetric naming with multicast concepts</li><li>Precise technical terminology</li><li>Slightly clearer intent for RPC responses</li></ul><p><strong>Cons:</strong></p><ul><li><strong>Networking jargon</strong> — Not idiomatic in web development</li><li><strong>High learning curve</strong> — Developers unfamiliar with term</li><li><strong>Poor IDE discoverability</strong> — Not the first method they&#39;d try</li><li><strong>Documentation overhead</strong> — Requires definition and rationale</li><li><strong>Inconsistent with platforms</strong> — No major WebSocket library uses this</li><li><strong>Less familiar to beginners</strong> — Requires OSI layer knowledge</li></ul><p><strong>Verdict</strong>: Too much cognitive burden for marginal semantic gain.</p><hr><h3 id="hybrid-approach-alias-both" tabindex="-1">Hybrid Approach: Alias Both <a class="header-anchor" href="#hybrid-approach-alias-both" aria-label="Permalink to &quot;Hybrid Approach: Alias Both&quot;">​</a></h3><p>Provide both <code>send()</code> (canonical) and <code>unicast()</code> (alias):</p><p><strong>Pros:</strong></p><ul><li>Backward compatibility if names change later</li><li>Accommodates different naming preferences</li></ul><p><strong>Cons:</strong></p><ul><li><strong>API surface bloat</strong> — Two methods for same operation</li><li><strong>Discoverability confusion</strong> — Which should developers use?</li><li><strong>Maintenance burden</strong> — Both must be documented and tested</li><li><strong>Against design philosophy</strong> — Single canonical path preferred</li><li><strong>Unused at adoption</strong> — Historical aliasing anti-pattern</li></ul><p><strong>Verdict</strong>: Rejected; violates simplicity principle.</p><hr><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to &quot;Consequences&quot;">​</a></h2><h3 id="✅-positive" tabindex="-1">✅ Positive <a class="header-anchor" href="#✅-positive" aria-label="Permalink to &quot;✅ Positive&quot;">​</a></h3><ol><li><strong>Zero learning curve</strong> — Every web developer knows <code>send()</code></li><li><strong>Instant recognition</strong> — Familiar from WebSocket API and modern libraries</li><li><strong>Natural mental model</strong> — Maps directly to platform concepts</li><li><strong>Clear intent</strong> — <code>send()</code> (one) vs <code>publish()</code> (many) distinction</li><li><strong>Consistent with precedent</strong> — uWebSockets.js already uses this pattern</li><li><strong>Lower documentation burden</strong> — Less explanation needed</li><li><strong>IDE-friendly</strong> — Natural first method developers try</li></ol><h3 id="⚠️-trade-offs" tabindex="-1">⚠️ Trade-offs <a class="header-anchor" href="#⚠️-trade-offs" aria-label="Permalink to &quot;⚠️ Trade-offs&quot;">​</a></h3><ol><li><p><strong>Slightly less explicit</strong> — <code>send()</code> doesn&#39;t literally say &quot;unicast&quot;</p><ul><li><strong>Mitigation</strong>: Documentation clarifies <code>ctx.send()</code> = &quot;send to current connection&quot;</li><li><strong>RPC pattern</strong>: Use <code>ctx.reply()</code> for explicit RPC responses</li></ul></li><li><p><strong>Context-dependent</strong> — Semantics depend on call site:</p><ul><li>In <code>router.on()</code> handler: sends to current connection (unicast)</li><li>In lifecycle callback: same meaning (current context)</li><li><strong>Mitigation</strong>: Handler context always represents single connection; no ambiguity</li></ul></li><li><p><strong>Potential confusion</strong> — Different from networking layer terminology</p><ul><li><strong>Mitigation</strong>: Marketing and docs emphasize &quot;web developer first, not network engineer&quot;</li></ul></li></ol><hr><h2 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to &quot;Implementation&quot;">​</a></h2><p><strong>Already implemented</strong> in:</p><ul><li><code>/packages/core/src/types.ts</code> — <code>SendFunction</code> interface</li><li><code>/packages/core/src/router.ts</code> — <code>ctx.send()</code> implementation</li><li><code>/packages/client/src/index.ts</code> — <code>client.send()</code> implementation</li></ul><p><strong>Documentation</strong>:</p><ul><li><code>docs/specs/router.md</code> — Handler context API (line 278)</li><li><code>docs/specs/client.md</code> — Client API</li><li><code>CLAUDE.md</code> — Quick start examples</li></ul><hr><h2 id="validation-real-world-comparison" tabindex="-1">Validation: Real-World Comparison <a class="header-anchor" href="#validation-real-world-comparison" aria-label="Permalink to &quot;Validation: Real-World Comparison&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>Scenario</strong></th><th><strong>Using <code>send()</code></strong></th><th><strong>Using <code>unicast()</code></strong></th></tr></thead><tbody><tr><td>New developer asks: &quot;How do I send a message to a client?&quot;</td><td>✅ First instinct: &quot;use <code>send()</code>&quot;</td><td>❌ &quot;What&#39;s unicast?&quot;</td></tr><tr><td>IDE autocomplete: <code>ctx.</code></td><td>✅ <code>send</code> is first option</td><td>❌ <code>unicast</code> less discoverable</td></tr><tr><td>Error message: &quot;Cannot send message&quot;</td><td>✅ Instantly understood</td><td>❌ &quot;Unicast? Do I want that?&quot;</td></tr><tr><td>Documentation example</td><td>✅ <code>ctx.send(schema, data)</code> — familiar</td><td>❌ <code>ctx.send(...)</code> — requires explanation</td></tr><tr><td>RPC response semantics</td><td>✅ <code>ctx.reply()</code> clarifies intent</td><td>❌ Is <code>unicast()</code> the reply method?</td></tr><tr><td>Onboarding time</td><td>✅ ~5 minutes (zero learning)</td><td>❌ ~15 minutes (definition + motivation)</td></tr></tbody></table><hr><h2 id="related-decisions" tabindex="-1">Related Decisions <a class="header-anchor" href="#related-decisions" aria-label="Permalink to &quot;Related Decisions&quot;">​</a></h2><ul><li><strong>ADR-018</strong> — <code>publish()</code> chosen for multicast (industry standard)</li><li><strong>ADR-019</strong> — <code>ctx.publish()</code> convenience method for handlers</li><li><strong>ADR-017</strong> — Parameter naming: <code>payload</code>, <code>response</code>, <code>meta</code></li><li><strong>ADR-015</strong> — RPC API: <code>ctx.reply()</code> and <code>ctx.progress()</code></li></ul><hr><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><h3 id="implementation-1" tabindex="-1">Implementation <a class="header-anchor" href="#implementation-1" aria-label="Permalink to &quot;Implementation&quot;">​</a></h3><ul><li><code>packages/core/src/router.ts</code> — Router.send() implementation</li><li><code>packages/core/src/types.ts</code> — SendFunction type definition</li><li><code>packages/client/src/index.ts</code> — Client.send() implementation</li></ul><h3 id="specification" tabindex="-1">Specification <a class="header-anchor" href="#specification" aria-label="Permalink to &quot;Specification&quot;">​</a></h3><ul><li><code>docs/specs/router.md</code> — Handler context and API reference</li><li><code>docs/specs/client.md</code> — Client API documentation</li></ul><h3 id="industry-precedent" tabindex="-1">Industry Precedent <a class="header-anchor" href="#industry-precedent" aria-label="Permalink to &quot;Industry Precedent&quot;">​</a></h3><ul><li><strong>WebSocket API</strong>: <code>WebSocket.send()</code> (W3C standard)</li><li><strong>ws</strong>: <code>ws.send(data)</code> (popular Node.js library)</li><li><strong>uWebSockets.js</strong>: <code>ws.send()</code> / <code>ws.publish()</code></li><li><strong>SignalR</strong>: <code>connection.send()</code> for fire-and-forget</li><li><strong>Bun WebSocket</strong>: <code>ws.send()</code> (built-in API)</li></ul>`,57)])])}const u=i(a,[["render",o]]);export{g as __pageData,u as default};
