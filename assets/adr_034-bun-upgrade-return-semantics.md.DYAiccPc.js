import{x as s,a as t,f as i,p as a}from"./chunks/framework.DdttWuXo.js";const u=JSON.parse('{"title":"ADR-034: WebSocket Upgrade Return Semantics for Bun","description":"","frontmatter":{},"headers":[],"relativePath":"adr/034-bun-upgrade-return-semantics.md","filePath":"adr/034-bun-upgrade-return-semantics.md","lastUpdated":1763305236000}'),n={name:"adr/034-bun-upgrade-return-semantics.md"};function r(o,e,l,d,c,h){return i(),t("div",null,[...e[0]||(e[0]=[a(`<h1 id="adr-034-websocket-upgrade-return-semantics-for-bun" tabindex="-1">ADR-034: WebSocket Upgrade Return Semantics for Bun <a class="header-anchor" href="#adr-034-websocket-upgrade-return-semantics-for-bun" aria-label="Permalink to “ADR-034: WebSocket Upgrade Return Semantics for Bun”">​</a></h1><p><strong>Status</strong>: ✅ Implemented</p><p><strong>Date</strong>: 2025-11-16</p><p><strong>Related</strong>: <a href="./031-plugin-adapter-architecture">ADR-031 Plugin-Adapter Architecture</a>, <a href="./../specs/adapters">adapters.md spec</a></p><h2 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to “Context”">​</a></h2><p>Bun&#39;s <code>fetch</code> handler implements a <strong>strict runtime contract</strong> for WebSocket upgrades:</p><ul><li>When <code>server.upgrade(req, ...)</code> returns <code>true</code>, Bun has <strong>internally sent the 101 response</strong> and completed the HTTP exchange</li><li>Bun <strong>does not expect</strong> the fetch handler to return a <code>Response</code> on successful upgrade</li><li>Returning a <code>Response</code> after successful upgrade violates this contract and may cause runtime errors</li></ul><p>The original <code>@ws-kit/bun</code> adapter returned <code>new Response(null, { status: 200 })</code> on success, contradicting this contract. This is a <strong>platform runtime invariant</strong> that must be satisfied.</p><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to “Decision”">​</a></h2><p>The <code>BunHandler.fetch</code> handler MUST:</p><ol><li><p><strong>Return <code>void</code> (nothing) on successful WebSocket upgrade</strong></p><ul><li>Signals Bun that the HTTP request is fully handled and the socket is now a WebSocket</li><li>No HTTP response is sent or expected after a successful upgrade</li></ul></li><li><p><strong>Return <code>Response</code> only on failure</strong></p><ul><li><code>400</code> (invalid handshake) when <code>server.upgrade()</code> returns <code>false</code></li><li><code>500</code> (unexpected adapter error) when authentication or processing throws</li></ul></li><li><p><strong>Widen the type</strong> to <code>Response | void | Promise&lt;Response | void&gt;</code></p><ul><li>Makes the contract explicit; <code>void</code> return is valid and expected</li><li>Type system enforces correct handling in composition</li></ul></li><li><p><strong>Extract upgrade logic</strong> into <code>attemptWebSocketUpgrade()</code> helper</p><ul><li>Isolates UUID generation, authentication, data preparation from return-value semantics</li><li>Enables isolated unit testing</li><li>Clarifies separation of concerns</li></ul></li></ol><p><strong>This establishes the Adapter Fetch Contract for Bun platform adapters.</strong></p><h2 id="rationale" tabindex="-1">Rationale <a class="header-anchor" href="#rationale" aria-label="Permalink to “Rationale”">​</a></h2><h3 id="runtime-correctness" tabindex="-1">Runtime Correctness <a class="header-anchor" href="#runtime-correctness" aria-label="Permalink to “Runtime Correctness”">​</a></h3><p>Bun terminates the fetch handler immediately after a successful upgrade. Returning <code>Response</code> violates this invariant and risks &quot;headers already sent&quot; or undefined behavior in current or future Bun versions. Aligning the adapter with Bun&#39;s documented behavior is non-negotiable.</p><p>This also aligns with ADR-030: context is created <strong>after</strong> the WebSocket upgrade, not before.</p><h3 id="fetch-handler-composition" tabindex="-1">Fetch Handler Composition <a class="header-anchor" href="#fetch-handler-composition" aria-label="Permalink to “Fetch Handler Composition”">​</a></h3><p>By establishing that successful upgrades return <code>void</code>, fetch handler composition becomes safe and predictable:</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">server</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isWebSocketPath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> wsFetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req, server); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// May return void (success) or Response (error)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> httpFetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(req); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Always returns Response</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Plugin authors and middleware developers can rely on this contract.</p><h3 id="type-safety" tabindex="-1">Type Safety <a class="header-anchor" href="#type-safety" aria-label="Permalink to “Type Safety”">​</a></h3><p>The widened return type makes the contract visible at the type level:</p><ul><li>TypeScript errors if code assumes always-<code>Response</code></li><li>Prevents undefined-passed-to-Response bugs</li><li>Clarifies that both outcomes are valid</li></ul><h3 id="correct-http-semantics" tabindex="-1">Correct HTTP Semantics <a class="header-anchor" href="#correct-http-semantics" aria-label="Permalink to “Correct HTTP Semantics”">​</a></h3><ul><li><code>400</code> for invalid WebSocket requests (client&#39;s responsibility)</li><li><code>500</code> only for unexpected adapter failures (server&#39;s responsibility)</li><li>Clearer signal for monitoring and debugging</li></ul><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to “Consequences”">​</a></h2><h3 id="positive" tabindex="-1">Positive <a class="header-anchor" href="#positive" aria-label="Permalink to “Positive”">​</a></h3><ul><li>✅ <strong>Correct Runtime Behavior</strong>: No violation of Bun&#39;s fetch contract</li><li>✅ <strong>Type-Safe Composition</strong>: Handler composition is safe and predictable</li><li>✅ <strong>Isolated Testing</strong>: <code>attemptWebSocketUpgrade()</code> is unit-testable in isolation</li><li>✅ <strong>Better Diagnostics</strong>: HTTP status codes align with actual error cause</li></ul><h3 id="trade-offs" tabindex="-1">Trade-offs <a class="header-anchor" href="#trade-offs" aria-label="Permalink to “Trade-offs”">​</a></h3><ul><li><p>⚠️ <strong>Type Breaking Change</strong>: Code directly typing <code>BunHandler.fetch</code> must handle <code>void</code> returns</p><ul><li>Mitigation: Most users call <code>serve()</code> or <code>createDefaultBunFetch</code>, which work seamlessly</li><li>Type errors guide developers to the correct pattern</li></ul></li><li><p>⚠️ <strong>HTTP Status Change</strong>: Upgrade failures now return <code>400</code> instead of <code>500</code></p><ul><li>This is correct semantically (client error, not server error)</li><li>Monitoring rules should be updated</li></ul></li><li><p>⚠️ <strong>Composition Awareness</strong>: Code wrapping or intercepting fetch handlers must account for <code>void</code> returns</p><ul><li>Middleware that logs/inspects responses should check for <code>undefined</code> first</li></ul></li></ul><h2 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to “Implementation”">​</a></h2><p>All changes are in <code>packages/bun/src/</code>:</p><ul><li><strong>handler.ts</strong>: Extract <code>attemptWebSocketUpgrade()</code>, simplify <code>fetch()</code> to return <code>void</code> on success, <code>Response</code> on failure</li><li><strong>types.ts</strong>: Widen <code>BunHandler.fetch</code> return type to <code>Response | void | Promise&lt;Response | void&gt;</code></li><li><strong>Tests</strong>: Assert <code>undefined</code> on success, <code>400</code> on failure (not <code>500</code>)</li></ul><h2 id="scope" tabindex="-1">Scope <a class="header-anchor" href="#scope" aria-label="Permalink to “Scope”">​</a></h2><p><strong>This ADR applies to the Bun platform adapter only.</strong> Other runtimes (Node, Cloudflare, Deno) have different upgrade semantics. Each adapter MUST define its own fetch contract consistent with its platform&#39;s upgrade model.</p><p>For routing non-WebSocket requests in multiplexed scenarios, see <a href="./../specs/adapters">adapters.md: routing patterns</a>.</p><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to “References”">​</a></h2><ul><li><a href="https://bun.sh/docs/api/websockets#upgrade" target="_blank" rel="noreferrer">Bun <code>server.upgrade()</code> documentation</a></li><li><a href="./031-plugin-adapter-architecture">ADR-031: Plugin-Adapter Architecture</a></li></ul>`,38)])])}const g=s(n,[["render",r]]);export{u as __pageData,g as default};
