import{v as a,a as s,f as t,l as i}from"./chunks/framework.DyFmBNkj.js";const g=JSON.parse('{"title":"Delta Sync Application Pattern","description":"","frontmatter":{},"headers":[],"relativePath":"patterns/delta-sync.md","filePath":"patterns/delta-sync.md","lastUpdated":1762079697000}'),n={name:"patterns/delta-sync.md"};function l(r,e,o,p,d,c){return t(),s("div",null,[...e[0]||(e[0]=[i(`<h1 id="delta-sync-application-pattern" tabindex="-1">Delta Sync Application Pattern <a class="header-anchor" href="#delta-sync-application-pattern" aria-label="Permalink to “Delta Sync Application Pattern”">​</a></h1><p>Efficient bandwidth via operation deltas with fallback snapshots for state synchronization.</p><p><strong>Spec-Version:</strong> 1.0.0 | <strong>Invariants:</strong> <a href="./../invariants">docs/invariants.md</a></p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to “Overview”">​</a></h2><p>Delta sync sends only state changes (deltas) instead of full state on each update. This reduces bandwidth significantly in collaborative and real-time applications, especially with many concurrent users or large state objects.</p><h2 id="architecture" tabindex="-1">Architecture <a class="header-anchor" href="#architecture" aria-label="Permalink to “Architecture”">​</a></h2><p><strong>Server state:</strong></p><ol><li>Maintain global revision counter (incremented per operation)</li><li>Store operation history in ring buffer (e.g., last 1024 operations)</li><li>Keep current state snapshot for far-behind clients</li><li>Track each client&#39;s <code>lastSentRev</code> (last revision sent to that client)</li></ol><p><strong>Client state:</strong></p><ol><li>Track <code>serverRev</code> (last received revision from server)</li><li>Maintain pending operations (optimistically applied locally)</li><li>Merge incoming deltas and snapshots into materialized view</li></ol><h2 id="server-must" tabindex="-1">Server MUST <a class="header-anchor" href="#server-must" aria-label="Permalink to “Server MUST”">​</a></h2><ol><li>Increment global revision counter on every state change</li><li>Store each operation with its revision in a ring buffer</li><li>For each client, compute delta (operations since <code>lastSentRev</code>)</li><li>If delta is unavailable (client too far behind), send full snapshot instead</li><li>Include revision metadata in state messages: <code>rev</code> for snapshots, <code>fromRev</code>/<code>toRev</code> for deltas</li><li>Track per-client <code>lastSentRev</code> to compute deltas correctly</li></ol><h2 id="client-must" tabindex="-1">Client MUST <a class="header-anchor" href="#client-must" aria-label="Permalink to “Client MUST”">​</a></h2><ol><li>Track <code>serverRev</code> from received messages</li><li>Apply incoming deltas in order (maintain FIFO)</li><li>Fall back to full refresh if <code>SNAPSHOT</code> received instead of deltas</li><li>Implement optimistic updates (apply pending ops before server confirmation)</li><li>Rebase pending operations after conflict resolution</li></ol><h2 id="recovery-strategy" tabindex="-1">Recovery Strategy <a class="header-anchor" href="#recovery-strategy" aria-label="Permalink to “Recovery Strategy”">​</a></h2><p>When a client falls too far behind (revision gap exceeds buffer size), the server:</p><ol><li>Sends a <code>REVISION_GAP</code> error message with metadata about the gap</li><li>Then sends a <strong>full snapshot</strong> for recovery</li></ol><p>The client discards pending operations and applies the snapshot, then resumes delta sync on subsequent updates.</p><div class="language-text"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>Client (offline 30s)     Server (rev=100, buffer=75-100)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    reconnect            &gt;</span></span>
<span class="line"><span>                             check: expected 50, have 75</span></span>
<span class="line"><span>                             (gap too large, send error + snapshot)</span></span>
<span class="line"><span>    &lt;   REVISION_GAP      $ expectedRev=50, serverRev=100, bufferFirstRev=75</span></span>
<span class="line"><span>    &lt;   snapshot         $ rev=100, state={}</span></span>
<span class="line"><span>    discard pending      $</span></span>
<span class="line"><span>    apply full state     $</span></span>
<span class="line"><span>    resume delta sync    $</span></span></code></pre></div><h2 id="timelines" tabindex="-1">Timelines <a class="header-anchor" href="#timelines" aria-label="Permalink to “Timelines”">​</a></h2><p><strong>Happy path (delta sync):</strong></p><div class="language-mermaid"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sequenceDiagram</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    participant Client</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    participant Server as Server (rev=100)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;Server: connect</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Note over Server: remember&lt;br/&gt;lastSentRev=0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Server-&gt;&gt;Client: snapshot&lt;br/&gt;rev=100, state={}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;Client: lastRev=100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;Client: user action&lt;br/&gt;(pending op)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Server-&gt;&gt;Client: delta&lt;br/&gt;rev=101, ops=[op1]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;Client: apply ops&lt;br/&gt;lastRev=101</span></span></code></pre></div><p><strong>Far-behind recovery (snapshot fallback):</strong></p><div class="language-mermaid"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sequenceDiagram</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    participant Client as Client (offline 30s)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    participant Server as Server (rev=100,&lt;br/&gt;buffer=75-100)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;Server: reconnect</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Note over Server: check: expected 50, have 75&lt;br/&gt;(gap too large,&lt;br/&gt;send snapshot)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Server-&gt;&gt;Client: snapshot&lt;br/&gt;rev=100, state={}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Client-&gt;&gt;Client: discard pending&lt;br/&gt;apply full state</span></span></code></pre></div><h2 id="failure-modes" tabindex="-1">Failure Modes <a class="header-anchor" href="#failure-modes" aria-label="Permalink to “Failure Modes”">​</a></h2><table tabindex="0"><thead><tr><th>Condition</th><th>Error</th><th>Retryable</th><th>Client Action</th></tr></thead><tbody><tr><td>Client far behind (rev gap &gt; buffer)</td><td><code>REVISION_GAP</code></td><td>yes</td><td>Receive <code>REVISION_GAP</code> metadata, then accept <code>SYNC.SNAPSHOT</code> and discard pending ops</td></tr><tr><td>Concurrent client updates</td><td>(via deltas)</td><td>n/a</td><td>Apply deltas in order, rebase pending ops, ack confirmed ops via <code>clientReqId</code></td></tr><tr><td>Unauthorized update</td><td><code>UNAUTHENTICATED</code></td><td>no</td><td>Reconnect with valid credentials and rejoin</td></tr></tbody></table><h2 id="key-implementation-details" tabindex="-1">Key Implementation Details <a class="header-anchor" href="#key-implementation-details" aria-label="Permalink to “Key Implementation Details”">​</a></h2><ol><li><strong>Ring Buffer</strong> — Fixed-size circular buffer prevents unbounded memory growth</li><li><strong>Revision Tracking</strong> — Allows efficient delta computation without full state copies</li><li><strong>Per-Client State</strong> — Each client has independent <code>lastSentRev</code> for personalized deltas</li><li><strong>Optimistic Updates</strong> — Apply pending ops locally before server confirmation</li><li><strong>Fallback Strategy</strong> — Send snapshots when buffer doesn&#39;t have enough history</li></ol><h2 id="conformance" tabindex="-1">Conformance <a class="header-anchor" href="#conformance" aria-label="Permalink to “Conformance”">​</a></h2><p>Delta sync ships with three fixtures validating core scenarios:</p><ol><li><strong>001-happy-path</strong> — Client joins, receives snapshot, then receives deltas on updates</li><li><strong>002-revision-gap</strong> — Client falls behind buffer, receives <code>REVISION_GAP</code> error + snapshot</li><li><strong>003-optimistic-update</strong> — Client sends update, receives server confirmation via <code>clientReqId</code></li></ol><p>Run conformance tests with:</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bun</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> test</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> examples/delta-sync/conformance.test.ts</span></span></code></pre></div><h2 id="limitations" tabindex="-1">Limitations <a class="header-anchor" href="#limitations" aria-label="Permalink to “Limitations”">​</a></h2><ul><li>No persistence layer; in-memory ring buffer only</li><li>No automatic backpressure; assumes clients handle snapshots gracefully</li><li>No encryption; suitable for trusted networks only</li></ul>`,35)])])}const k=a(n,[["render",l]]);export{g as __pageData,k as default};
