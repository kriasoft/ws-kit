import{_ as i,c as a,o as e,ag as t}from"./chunks/framework.DbtdwhWj.js";const c=JSON.parse('{"title":"ADR-004: Typed Router Factory Pattern","description":"","frontmatter":{},"headers":[],"relativePath":"adr/004-typed-router-factory.md","filePath":"adr/004-typed-router-factory.md","lastUpdated":1761868280000}'),n={name:"adr/004-typed-router-factory.md"};function r(l,s,p,h,o,k){return e(),a("div",null,[...s[0]||(s[0]=[t(`<h1 id="adr-004-typed-router-factory-pattern" tabindex="-1">ADR-004: Typed Router Factory Pattern <a class="header-anchor" href="#adr-004-typed-router-factory-pattern" aria-label="Permalink to &quot;ADR-004: Typed Router Factory Pattern&quot;">​</a></h1><h2 id="metadata" tabindex="-1">Metadata <a class="header-anchor" href="#metadata" aria-label="Permalink to &quot;Metadata&quot;">​</a></h2><ul><li><strong>Date</strong>: 2025-10-29</li><li><strong>Status</strong>: Superseded by ADR-005, ADR-007</li><li><strong>Tags</strong>: architecture, type-safety, developer-experience, API design</li></ul><blockquote><p><strong>⚠️ Superseded:</strong> This ADR describes the original factory pattern approach. As of Phase 2 (v1.3), the API has evolved to use:</p><ul><li><strong>ADR-005</strong>: Builder Pattern with Symbol escape hatch (replaces Proxy approach)</li><li><strong>ADR-007</strong>: Export-with-Helpers Pattern (replaces <code>createMessageSchema()</code> factory)</li></ul><p>The concepts here remain valid for understanding type preservation, but implementation details have changed. See ADR-005 and ADR-007 for current approach.</p></blockquote><h2 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;Context&quot;">​</a></h2><p>The <code>WebSocketRouter</code> core implementation is validator-agnostic by design—it accepts a <code>ValidatorAdapter</code> and works with Zod, Valibot, or custom validators. This flexibility comes at a type safety cost.</p><h3 id="the-type-erasure-problem" tabindex="-1">The Type Erasure Problem <a class="header-anchor" href="#the-type-erasure-problem" aria-label="Permalink to &quot;The Type Erasure Problem&quot;">​</a></h3><p>When handlers are registered with <code>router.on(schema, handler)</code>, the router stores them in a <code>Map&lt;string, MessageHandlerEntry&gt;</code>:</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.messageHandlers.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(messageType, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  schema,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  handler: handler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MessageHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MessageSchemaType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Type erased here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>TypeScript cannot track the specific schema type through Map storage due to:</p><ol><li><strong>Generic erasure</strong>: The core router uses <code>MessageSchemaType = any</code> for validator agnosticism</li><li><strong>Map constraints</strong>: A <code>Map&lt;K, V&gt;</code> cannot preserve individual value types</li><li><strong>Handler type loss</strong>: Stored handlers resolve to the generic <code>MessageContext&lt;TData&gt;</code>, losing payload type information</li></ol><p>This forces developers to use type assertions when accessing payloads:</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(PingMessage, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Without factory pattern:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx.payload </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ← Type assertion required</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // With factory pattern (createZodRouter):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx.payload; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ← Full type inference, no assertion</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>See ADR-001 for the conditional payload typing strategy that reduces this burden, but it cannot completely eliminate it when using the core <code>WebSocketRouter</code> directly.</p><h3 id="why-this-matters" tabindex="-1">Why This Matters <a class="header-anchor" href="#why-this-matters" aria-label="Permalink to &quot;Why This Matters&quot;">​</a></h3><p>Developers expect type inference to work naturally when using TypeScript. The gap between schema definition and handler implementation creates friction:</p><ul><li>Examples require <code>as any</code> casts, signaling that type safety is compromised</li><li>Developers unfamiliar with generic type limitations may suspect a library deficiency</li><li>Runtime errors can occur if schema and handler types diverge</li></ul><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to &quot;Decision&quot;">​</a></h2><p>Provide <strong>factory functions</strong> (exported as <code>createRouter</code> from validator packages) that wrap the core router and preserve type information through overloaded method signatures. This approach:</p><ol><li><strong>Preserves types</strong> through a thin wrapper facade</li><li><strong>Maintains API compatibility</strong> with the core router</li><li><strong>Introduces no runtime overhead</strong></li><li><strong>Enables gradual migration</strong> (opt-in, non-breaking)</li></ol><h3 id="implementation-pattern" tabindex="-1">Implementation Pattern <a class="header-anchor" href="#implementation-pattern" aria-label="Permalink to &quot;Implementation Pattern&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// packages/zod/src/router.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createZodRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocketData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocketData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Omit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WebSocketRouterOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;validator&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TypedZodRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> core</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocketRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;({</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">options,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    validator: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zodValidator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> typed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TypedZodRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">schema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // Type information preserved in wrapper&#39;s overloaded signature</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      core.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(schema, handler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Safe type cast internally</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> typed;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ... other methods (onOpen, onClose, etc.) proxy to core</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [Symbol.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ws-kit.core&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]: core, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Escape hatch for advanced introspection</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> typed;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The wrapper&#39;s <code>on</code> method is overloaded based on the schema:</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Wrapper signature - preserves payload type</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">on</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> extends Record</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">string, ZodTypeAny</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  schema: MessageSchema</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;TYPE_A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">P</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  handler: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ctx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MessageContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;{ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;TYPE_A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">payload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> z</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">infer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ZodObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">P</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt; }, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): TypedZodRouter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>This allows TypeScript to infer <code>ctx.payload</code> type correctly, even though the underlying core router uses generics.</p><h3 id="validation-specific-routers" tabindex="-1">Validation-Specific Routers <a class="header-anchor" href="#validation-specific-routers" aria-label="Permalink to &quot;Validation-Specific Routers&quot;">​</a></h3><p>Each validator adapter exports a factory (internally named <code>createZodRouter</code> or <code>createValibotRouter</code>) as <code>createRouter</code> for consistency:</p><ul><li><code>@ws-kit/zod</code>: <code>createRouter()</code> → <code>TypedZodRouter&lt;TData&gt;</code></li><li><code>@ws-kit/valibot</code>: <code>createRouter()</code> → <code>TypedValibotRouter&lt;TData&gt;</code></li></ul><p>Both provide identical developer experience, just with validator-specific types.</p><h2 id="alternatives-considered" tabindex="-1">Alternatives Considered <a class="header-anchor" href="#alternatives-considered" aria-label="Permalink to &quot;Alternatives Considered&quot;">​</a></h2><h3 id="_1-enhance-core-router-with-advanced-conditional-types" tabindex="-1">1. Enhance Core Router with Advanced Conditional Types <a class="header-anchor" href="#_1-enhance-core-router-with-advanced-conditional-types" aria-label="Permalink to &quot;1. Enhance Core Router with Advanced Conditional Types&quot;">​</a></h3><p><strong>Idea</strong>: Use TypeScript&#39;s conditional types to preserve schema types in the core router without wrapper.</p><p><strong>Why rejected</strong>:</p><ul><li>Conditional type inference breaks when storing handlers in <code>Map&lt;K, V&gt;</code></li><li>Router composition (via <code>addRoutes</code>) requires <code>MessageSchemaType | any</code> union, undermining type safety</li><li>Adds significant complexity to core types for theoretical benefit</li><li>Doesn&#39;t solve the erasure problem, just makes it harder to debug</li></ul><h3 id="_2-separate-validator-specific-router-classes" tabindex="-1">2. Separate Validator-Specific Router Classes <a class="header-anchor" href="#_2-separate-validator-specific-router-classes" aria-label="Permalink to &quot;2. Separate Validator-Specific Router Classes&quot;">​</a></h3><p><strong>Idea</strong>: Create <code>ZodRouter</code> and <code>ValibotRouter</code> classes that inherit from core router.</p><p><strong>Why rejected</strong>:</p><ul><li>Code duplication across validators</li><li>More complex maintenance (changes to core router require syncing across subclasses)</li><li>Inheritance over composition violates the library&#39;s composition principle</li><li>No better type safety than the factory wrapper approach</li></ul><h3 id="_3-generic-type-parameters-on-message-map" tabindex="-1">3. Generic Type Parameters on Message Map <a class="header-anchor" href="#_3-generic-type-parameters-on-message-map" aria-label="Permalink to &quot;3. Generic Type Parameters on Message Map&quot;">​</a></h3><p><strong>Idea</strong>: Use a registry pattern like <code>Map&lt;string, { schema, handler, types }&gt;</code> to preserve type metadata.</p><p><strong>Why rejected</strong>:</p><ul><li>Runtime overhead (metadata lookups)</li><li>Doesn&#39;t solve TypeScript&#39;s structural typing constraints</li><li>More complex and fragile than wrapper approach</li><li>Still requires internal type assertions</li></ul><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to &quot;Consequences&quot;">​</a></h2><h3 id="benefits" tabindex="-1">Benefits <a class="header-anchor" href="#benefits" aria-label="Permalink to &quot;Benefits&quot;">​</a></h3><p>✅ <strong>Perfect type inference</strong> - No <code>as any</code> assertions needed in handlers ✅ <strong>Zero runtime overhead</strong> - Wrapper is a thin facade, no logic duplication ✅ <strong>Backward compatible</strong> - Core <code>WebSocketRouter</code> still works as before ✅ <strong>Opt-in pattern</strong> - Developers choose to upgrade, no forced migration ✅ <strong>Composable</strong> - Router composition works with typed routers</p><h3 id="trade-offs" tabindex="-1">Trade-offs <a class="header-anchor" href="#trade-offs" aria-label="Permalink to &quot;Trade-offs&quot;">​</a></h3><p>⚠️ <strong>Two patterns exist</strong> - Developers may be confused by core <code>WebSocketRouter</code> vs validator-specific <code>createRouter()</code> ⚠️ <strong>Documentation needed</strong> - Must clearly explain when to use each approach ⚠️ <strong>Type test coverage</strong> - Requires comprehensive tests to validate type inference</p><h3 id="migration-path" tabindex="-1">Migration Path <a class="header-anchor" href="#migration-path" aria-label="Permalink to &quot;Migration Path&quot;">​</a></h3><p><strong>For new code</strong>:</p><ul><li>Use <code>createRouter()</code> from validator packages (<code>@ws-kit/zod</code> or <code>@ws-kit/valibot</code>) for full type safety</li></ul><p><strong>Example migration</strong> (zero breaking changes):</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Before - still works forever</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WebSocketRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  validator: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zodValidator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// After - recommended for new code</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createRouter } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@ws-kit/zod&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><ul><li><strong>ADR-001</strong>: MessageContext Conditional Payload Typing - Documents the payload type inference strategy that reduces but doesn&#39;t eliminate the need for this pattern</li><li><strong>Implementation</strong>: <ul><li><code>packages/zod/src/router.ts:59-116</code> - Zod typed router factory</li><li><code>packages/valibot/src/router.ts:59-116</code> - Valibot typed router factory</li><li><code>packages/zod/src/index.ts</code> - Factory export</li><li><code>packages/valibot/src/index.ts</code> - Factory export</li></ul></li><li><strong>Type Tests</strong>: <ul><li><code>packages/zod/test/types/router-inference.test.ts:1-415</code> - Comprehensive inference test coverage</li><li><code>packages/valibot/test/types/router-inference.test.ts</code> - Mirror tests for Valibot</li></ul></li><li><strong>Related</strong>: CLAUDE.md - Quick Start Guide (should reference typed routers)</li></ul>`,54)])])}const g=i(n,[["render",r]]);export{c as __pageData,g as default};
