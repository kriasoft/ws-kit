import{x as a,a as i,f as e,p as t}from"./chunks/framework.DdttWuXo.js";const c=JSON.parse('{"title":"ADR-033: Opaque Transport + Canonical ConnectionData","description":"","frontmatter":{},"headers":[],"relativePath":"adr/033-opaque-transport-canonical-connection-data.md","filePath":"adr/033-opaque-transport-canonical-connection-data.md","lastUpdated":1763674706000}'),n={name:"adr/033-opaque-transport-canonical-connection-data.md"};function l(r,s,p,o,h,d){return e(),i("div",null,[...s[0]||(s[0]=[t(`<h1 id="adr-033-opaque-transport-canonical-connectiondata" tabindex="-1">ADR-033: Opaque Transport + Canonical ConnectionData <a class="header-anchor" href="#adr-033-opaque-transport-canonical-connectiondata" aria-label="Permalink to “ADR-033: Opaque Transport + Canonical ConnectionData”">​</a></h1><p><strong>Status:</strong> Accepted <strong>Date:</strong> 2025-11-15 <strong>References:</strong> ADR-016 (ConnectionData Naming), ADR-021 (Adapter-First), ADR-031 (Plugin-Adapter Architecture)</p><hr><h2 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to “Context”">​</a></h2><p>The router stores per-connection state in a private <code>WeakMap&lt;ServerWebSocket, TContext&gt;</code> and surfaces it to user code via <code>ctx.data</code>. This design (introduced in recent refactoring) keeps state <strong>contained, testable, and platform-agnostic</strong>.</p><p>However, the codebase still contains numerous references assuming the old &quot;Bun-style&quot; pattern:</p><ul><li><code>ServerWebSocket&lt;TData&gt;</code> as a generic type in some adapters and plugins</li><li><code>ws.data</code> treated as the canonical state bag</li><li>Adapters, plugins, and tests reading/writing <code>ctx.data</code> directly</li></ul><h3 id="the-problem" tabindex="-1">The Problem <a class="header-anchor" href="#the-problem" aria-label="Permalink to “The Problem”">​</a></h3><ol><li><p><strong>Type safety broken</strong>: Bun&#39;s <code>@types/bun</code> defines <code>ServerWebSocket&lt;T&gt;</code>, but Cloudflare&#39;s <code>WebSocket</code> is non-generic. Core&#39;s own <code>ServerWebSocket</code> interface (in <code>platform-adapter.ts</code>) is intentionally non-generic to stay platform-agnostic. This creates type conflicts across adapters and plugins.</p></li><li><p><strong>Design drift</strong>: Router internals never touch <code>ws.data</code> anymore; they only use the WeakMap. So code that reads/writes <code>ctx.data</code> or <code>ws.data</code> is already <strong>unsound at runtime</strong>—it silently reads/writes nothing.</p></li><li><p><strong>Mental model collision</strong>: Two possible states bags (ctx.data and ws.data) invite bugs, especially across platform boundaries. Users don&#39;t know which one is canonical.</p></li></ol><h3 id="root-cause" tabindex="-1">Root Cause <a class="header-anchor" href="#root-cause" aria-label="Permalink to “Root Cause”">​</a></h3><p>When state moved from <code>ws.data</code> to <code>ctx.data</code>, the migration was incomplete. Docs, tests, and helper code still assume <code>ws.data</code> works.</p><hr><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to “Decision”">​</a></h2><p><strong><code>ServerWebSocket</code> is opaque transport. <code>ctx.data</code> (via <code>ConnectionData</code>) is the only canonical source of truth.</strong></p><h3 id="core-contract" tabindex="-1">Core Contract <a class="header-anchor" href="#core-contract" aria-label="Permalink to “Core Contract”">​</a></h3><p>Two related interfaces enforce the type boundary between public API and adapter internals:</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ws-kit/core/src/ws/platform-adapter.ts</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * PUBLIC: Opaque transport interface exposed to user code on ctx.ws.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Only send(), close(), and readyState are available.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ServerWebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * Send raw data (string or binary).</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * Only adapters and routers should call this; user code goes through ctx.send().</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ArrayBuffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * Close connection with optional code + reason.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * Only adapters and routers should call this; user code goes through ctx.close().</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reason</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * Connection state (CONNECTING | OPEN | CLOSING | CLOSED).</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   */</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  readyState</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;CONNECTING&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;OPEN&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;CLOSING&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;CLOSED&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * INTERNAL: Adapter-only interface extending ServerWebSocket with initialData.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * Only used by adapters and router internals; never exposed to user code.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AdapterWebSocket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ServerWebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * Optional: Initial connection context data set by adapter at upgrade time.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * Mutable during the brief window before router.websocket.open(ws).</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * Router reads initialData during handleOpen(), merges it into ctx.data,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * then no longer references it (adapter-only seed, not persisted).</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   */</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  initialData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Record</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unknown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>Type boundary rationale:</strong></p><ul><li><code>ServerWebSocket</code> is the public contract → only on <code>ctx.ws</code> → only send/close/readyState</li><li><code>AdapterWebSocket</code> is the internal contract → used by adapters and router → has mutable initialData</li><li>Casts from <code>ServerWebSocket</code> to <code>AdapterWebSocket</code> are only valid in adapter code and router internals</li><li>Platform-specific types (Bun&#39;s generic <code>ServerWebSocket&lt;T&gt;</code>, Cloudflare&#39;s <code>WebSocket</code>) are adapted to <code>AdapterWebSocket</code> before passing to router</li></ul><h3 id="state-api" tabindex="-1">State API <a class="header-anchor" href="#state-api" aria-label="Permalink to “State API”">​</a></h3><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ws-kit/core/src/context/base-context.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MinimalContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  TContext</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConnectionData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConnectionData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> clientId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ws</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ServerWebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Opaque transport (send, close, readyState only)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ Canonical state</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  assignData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">partial</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Partial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">TContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> extensions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">unknown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="adapter-contract" tabindex="-1">Adapter Contract <a class="header-anchor" href="#adapter-contract" aria-label="Permalink to “Adapter Contract”">​</a></h3><p>Adapters seed connection state by casting to <code>AdapterWebSocket</code> and setting <code>initialData</code> before passing to <code>router.websocket.open(ws)</code>:</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Example: Bun adapter</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. Receive Bun&#39;s WebSocket with attached .data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bun_ws</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Bun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ServerWebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;{ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">userId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /* from Bun */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. Cast to AdapterWebSocket to access initialData (adapter-only)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ws</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bun_ws </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AdapterWebSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. Extract platform data and attach as initialData</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.initialData </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  userId: bun_ws.data.userId,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  connectedAt: Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ... other fields from request headers, auth tokens, etc.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4. Pass to router (now typed as ServerWebSocket for handler)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> router.websocket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ws);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Router merges initialData into ctx.data during handleOpen(),</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// then discards it (one-time seed, not persisted on ws)</span></span></code></pre></div><p><strong>Key points:</strong></p><ul><li>Adapters cast to <code>AdapterWebSocket</code> to access mutable <code>initialData</code> field</li><li>Adapters extract platform-specific data and seed it via <code>initialData</code></li><li>Router checks for initialData during <code>handleOpen()</code> before firing lifecycle handlers</li><li>Data is merged into the WeakMap-backed <code>ctx.data</code> (permanent residence)</li><li><code>initialData</code> is NOT persisted after merge; it&#39;s a one-time seed at connection open</li><li>User code sees only <code>ServerWebSocket</code> (no <code>initialData</code> on <code>ctx.ws</code>)</li></ul><blockquote><p>⚠️ <strong>Note on types:</strong> <code>AdapterWebSocket.initialData</code> remains <code>Record&lt;string, unknown&gt;</code>. Core cannot infer the adapter&#39;s platform-specific shape. Adapters must keep the runtime fields they seed aligned with their project&#39;s <code>ConnectionData</code> module augmentation—TypeScript only regains full fidelity once the router merges <code>initialData</code> into <code>ctx.data</code>.</p></blockquote><h3 id="documentation-covenant" tabindex="-1">Documentation Covenant <a class="header-anchor" href="#documentation-covenant" aria-label="Permalink to “Documentation Covenant”">​</a></h3><p>User code MUST treat <code>ServerWebSocket</code> as opaque transport. Only use <code>send()</code>, <code>close()</code>, and <code>readyState</code>. All per-connection state lives in <code>ctx.data</code>:</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@ws-kit/core&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConnectionData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    userId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    roles</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(SomeMessage, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ctx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ✅ Correct: read/write from ctx.data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> userId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx.data.userId;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">assignData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ roles: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;admin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ✅ Use socket for transport only</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(someBuffer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ctx.ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ctx.ws.readyState;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ❌ Never do this:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ctx.data.userId;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // ← ws has no .data field; use ctx.data instead</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // (ctx.ws as any).data.userId;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ← Bypasses type safety; use ctx.data instead</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ctx.ws.initialData;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // ← Adapter-only; already merged into ctx.data during open</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><hr><h2 id="alternatives-considered" tabindex="-1">Alternatives Considered <a class="header-anchor" href="#alternatives-considered" aria-label="Permalink to “Alternatives Considered”">​</a></h2><h3 id="_1-re-introduce-generic-serverwebsocket-tdata" tabindex="-1">1. Re-introduce Generic <code>ServerWebSocket&lt;TData&gt;</code> <a class="header-anchor" href="#_1-re-introduce-generic-serverwebsocket-tdata" aria-label="Permalink to “1. Re-introduce Generic ServerWebSocket&lt;TData&gt;”">​</a></h3><p>Make core own a generic interface again and sync <code>ws.data</code> with the WeakMap.</p><p><strong>Pros:</strong></p><ul><li>Matches Bun&#39;s type signature</li><li>Familiar to Bun users</li></ul><p><strong>Cons:</strong></p><ul><li>Two mutable sources of truth (WeakMap + ws.data can drift)</li><li>Couples core to platform generics (ADR-021 violation)</li><li>Extra runtime overhead syncing both stores</li><li>Complicates Cloudflare/future platforms that don&#39;t have <code>.data</code></li></ul><h3 id="_2-introduce-platformwebsocket-tdata-interface-in-core" tabindex="-1">2. Introduce <code>PlatformWebSocket&lt;TData&gt;</code> interface in core <a class="header-anchor" href="#_2-introduce-platformwebsocket-tdata-interface-in-core" aria-label="Permalink to “2. Introduce PlatformWebSocket&lt;TData&gt; interface in core”">​</a></h3><p>Define a new abstraction in core that all adapters must implement.</p><p><strong>Pros:</strong></p><ul><li>Future-proof for multi-platform support</li><li>Cleaner abstraction boundary</li></ul><p><strong>Cons:</strong></p><ul><li>Adds complexity before it&#39;s needed (premature abstraction)</li><li>Core already has the right design (WeakMap + opaque ws); adding generics makes it worse</li><li>If we need this later, it&#39;s a small, backwards-compatible ADR</li></ul><h3 id="_3-type-assertions-ws-as-serverwebsocket-tdata-data" tabindex="-1">3. Type assertions (<code>(ws as ServerWebSocket&lt;TData&gt;).data</code>) <a class="header-anchor" href="#_3-type-assertions-ws-as-serverwebsocket-tdata-data" aria-label="Permalink to “3. Type assertions ((ws as ServerWebSocket&lt;TData&gt;).data)”">​</a></h3><p>Quick fix with <code>// @ts-ignore</code> or casts.</p><p><strong>Pros:</strong></p><ul><li>Minimal immediate changes</li></ul><p><strong>Cons:</strong></p><ul><li>Hides the problem, defers the fix</li><li>Makes code unsound and untestable</li><li>Violates our principle: &quot;safety over micro-optimizations&quot;</li></ul><hr><h2 id="rationale" tabindex="-1">Rationale <a class="header-anchor" href="#rationale" aria-label="Permalink to “Rationale”">​</a></h2><h3 id="_1-simplicity-and-correctness" tabindex="-1">1. Simplicity and Correctness <a class="header-anchor" href="#_1-simplicity-and-correctness" aria-label="Permalink to “1. Simplicity and Correctness”">​</a></h3><p>The router <strong>already</strong> uses <code>WeakMap&lt;ServerWebSocket, TContext&gt;</code> + <code>ctx.data</code> exclusively. This ADR formalizes that reality and cleans up the code to match the implementation.</p><ul><li><strong>One source of truth</strong> → no drift bugs (only WeakMap-backed <code>ctx.data</code>, never <code>ws.data</code>)</li><li><strong>Platform-agnostic</strong> → core stays lean, adapters own platform translation</li><li><strong>Testable</strong> → mock <code>ConnectionData</code> directly, not platform sockets</li></ul><h3 id="_2-aligns-with-plugin-adapter-design" tabindex="-1">2. Aligns with Plugin-Adapter Design <a class="header-anchor" href="#_2-aligns-with-plugin-adapter-design" aria-label="Permalink to “2. Aligns with Plugin-Adapter Design”">​</a></h3><p>ADR-031 established that <strong>adapters own platform quirks</strong>. This decision extends that:</p><ul><li>Core defines <code>ServerWebSocket</code> (minimal, non-generic)</li><li>Adapters wrap platform types (e.g., Bun&#39;s generic socket) <em>locally</em></li><li>Adapters expose plain <code>ServerWebSocket</code> to core</li><li>Core uses <code>initialData</code> hook to seed state via adapters</li></ul><p>No platform leakage into core.</p><h3 id="_3-better-dx-at-scale" tabindex="-1">3. Better DX at Scale <a class="header-anchor" href="#_3-better-dx-at-scale" aria-label="Permalink to “3. Better DX at Scale”">​</a></h3><p>When users see <code>ctx.data</code> everywhere (docs, examples, handlers), there&#39;s no ambiguity:</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Clear, teachable pattern:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. Define what lives on ctx.data (module augmentation)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. Read/write it in handlers via ctx.data and ctx.assignData()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. Don&#39;t touch ws at all (it&#39;s just send/close)</span></span></code></pre></div><p>This is simpler than:</p><blockquote><p>&quot;ctx.data is usually where state lives, but ctx.data also works, except it doesn&#39;t on Cloudflare, and also check the docs for which one syncs...&quot;</p></blockquote><h3 id="_4-backwards-compatible-migration-path" tabindex="-1">4. Backwards-Compatible Migration Path <a class="header-anchor" href="#_4-backwards-compatible-migration-path" aria-label="Permalink to “4. Backwards-Compatible Migration Path”">​</a></h3><p>The migration is safe because:</p><ul><li>Core&#39;s WeakMap <em>already</em> doesn&#39;t sync with <code>ws.data</code></li><li>Code reading/writing <code>ctx.data</code> may already be reading stale or undefined values across platforms</li><li>Fixing it now makes the error explicit (type error) instead of silent (undefined at runtime)</li></ul><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to “Consequences”">​</a></h2><h3 id="positive" tabindex="-1">Positive <a class="header-anchor" href="#positive" aria-label="Permalink to “Positive”">​</a></h3><ul><li>✅ <strong>Type safety restored</strong>: Adapters and plugins compile without workarounds</li><li>✅ <strong>Correctness</strong>: Code matches runtime behavior (WeakMap, not ws.data)</li><li>✅ <strong>Simplicity</strong>: One mental model (&quot;state lives in ctx.data&quot;)</li><li>✅ <strong>Platform-agnostic</strong>: Core stays independent of Bun/Cloudflare quirks</li><li>✅ <strong>Testability</strong>: Easier to mock ConnectionData than platform sockets</li><li>✅ <strong>Extensibility</strong>: Future platforms don&#39;t need to match Bun&#39;s <code>.data</code> pattern</li></ul><h3 id="negative" tabindex="-1">Negative <a class="header-anchor" href="#negative" aria-label="Permalink to “Negative”">​</a></h3><ul><li>❌ <strong>Breaking</strong>: Code that reads <code>ctx.data</code> will now fail at type-check time</li><li>❌ <strong>Migration effort</strong>: Documentation and examples need updates to use <code>ctx.data</code> instead</li></ul><h3 id="risks" tabindex="-1">Risks <a class="header-anchor" href="#risks" aria-label="Permalink to “Risks”">​</a></h3><p><strong>Risk</strong>: Users have code that relies on <code>ctx.data</code> working</p><p><strong>Mitigation</strong>: Router&#39;s WeakMap never wired <code>ws.data</code> to connection state, so such code was already reading stale/undefined values. This ADR makes the error visible (type error) instead of silent (undefined at runtime).</p><h3 id="adapter-guidance" tabindex="-1">Adapter Guidance <a class="header-anchor" href="#adapter-guidance" aria-label="Permalink to “Adapter Guidance”">​</a></h3><p>Adapters interact with <code>AdapterWebSocket</code> at the boundary, then pass to router:</p><p><strong>DO:</strong></p><ul><li>Receive platform-specific WebSocket (Bun&#39;s <code>ServerWebSocket&lt;T&gt;</code>, Cloudflare&#39;s <code>WebSocket</code>)</li><li>Cast to <code>AdapterWebSocket</code> to access mutable <code>initialData</code></li><li>Extract platform data and seed via <code>initialData</code> (one-time operation)</li><li>Pass to router as <code>ServerWebSocket</code> (no type assertion needed; AdapterWebSocket is a ServerWebSocket)</li></ul><p><strong>DON&#39;T:</strong></p><ul><li>Export or re-export <code>AdapterWebSocket</code> from adapter packages</li><li>Store state on <code>ws.data</code> after socket enters router control</li><li>Attempt to mutate <code>initialData</code> after <code>router.websocket.open(ws)</code> completes</li><li>Access <code>initialData</code> in user code (it&#39;s not there; use <code>ctx.data</code> instead)</li></ul><h3 id="plugin-test-access-patterns" tabindex="-1">Plugin &amp; Test Access Patterns <a class="header-anchor" href="#plugin-test-access-patterns" aria-label="Permalink to “Plugin &amp; Test Access Patterns”">​</a></h3><p>Plugins and test harnesses sometimes need access to internal router state (e.g., clientId lookup):</p><p><strong>For production plugins:</strong></p><ul><li>Always use <code>ctx.data</code> and <code>ctx.clientId</code> (publicly available)</li><li>Never attempt to infer state from <code>ctx.ws</code> (it&#39;s opaque transport)</li><li>If you need custom metadata, store it in <code>ctx.data</code> during <code>onOpen</code> lifecycle hook</li></ul><p><strong>For test fixtures and helpers:</strong></p><ul><li><p>Import helpers from <code>@ws-kit/core/testing</code>:</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  createTestRouter,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  wrapTestRouter,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  TestWebSocket,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  InMemoryPlatformAdapter,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@ws-kit/core/testing&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div></li><li><p>Prefer <code>createTestRouter()</code> / <code>wrapTestRouter()</code> and treat the resulting router/connection helpers as black boxes. The <code>testing</code> namespace re-export mirrors this API for ergonomics:</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { testing } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;@ws-kit/core/testing&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> testing.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTestRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() });</span></span></code></pre></div></li><li><p>For advanced assertions, <code>TestWebSocket</code> is still available from <code>@ws-kit/core/testing</code>; it implements <code>AdapterWebSocket</code> and exposes helpers like <code>getSentMessages()</code>. Keep this coupling confined to tests.</p></li></ul><p><strong>For internal routing</strong> (e.g., pubsub origin tracking):</p><ul><li>Pass <code>clientId</code> explicitly through plugin callbacks</li><li>Use <code>ctx.clientId</code> (always available) rather than inferring from <code>ws</code></li><li>Avoid creating new fields on <code>ServerWebSocket</code>; use <code>ctx.extensions</code> for plugin namespacing instead</li></ul><hr><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to “References”">​</a></h2><ul><li><strong>ADR-016</strong>: ConnectionData Naming—establishes ConnectionData pattern</li><li><strong>ADR-021</strong>: Adapter-First Architecture—adapters own platform details</li><li><strong>ADR-031</strong>: Plugin-Adapter Architecture—codifies plugin/adapter split</li><li><strong>ServerWebSocket</strong> interface: Core transport contract (platform-agnostic)</li><li><strong>MinimalContext</strong>: Base context type with <code>ctx.data</code> and <code>ctx.clientId</code></li><li>Specs: Router API, context lifecycle, and state management patterns</li></ul>`,92)])])}const g=a(n,[["render",l]]);export{c as __pageData,g as default};
