import{_ as c,C as p,c as h,o as a,a2 as i,b as s,j as r,w as t,a as l,G as o,a3 as d}from"./chunks/framework.Wvl1o-t0.js";const S=JSON.parse('{"title":"Delta Sync Application Pattern","description":"","frontmatter":{},"headers":[],"relativePath":"patterns/delta-sync.md","filePath":"patterns/delta-sync.md","lastUpdated":1762079697000}'),u={name:"patterns/delta-sync.md"};function v(m,e,f,g,b,y){const n=p("Mermaid");return a(),h("div",null,[e[2]||(e[2]=i(`<h1 id="delta-sync-application-pattern" tabindex="-1">Delta Sync Application Pattern <a class="header-anchor" href="#delta-sync-application-pattern" aria-label="Permalink to &quot;Delta Sync Application Pattern&quot;">​</a></h1><p>Efficient bandwidth via operation deltas with fallback snapshots for state synchronization.</p><p><strong>Spec-Version:</strong> 1.0.0 | <strong>Invariants:</strong> <a href="./../invariants">docs/invariants.md</a></p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Delta sync sends only state changes (deltas) instead of full state on each update. This reduces bandwidth significantly in collaborative and real-time applications, especially with many concurrent users or large state objects.</p><h2 id="architecture" tabindex="-1">Architecture <a class="header-anchor" href="#architecture" aria-label="Permalink to &quot;Architecture&quot;">​</a></h2><p><strong>Server state:</strong></p><ol><li>Maintain global revision counter (incremented per operation)</li><li>Store operation history in ring buffer (e.g., last 1024 operations)</li><li>Keep current state snapshot for far-behind clients</li><li>Track each client&#39;s <code>lastSentRev</code> (last revision sent to that client)</li></ol><p><strong>Client state:</strong></p><ol><li>Track <code>serverRev</code> (last received revision from server)</li><li>Maintain pending operations (optimistically applied locally)</li><li>Merge incoming deltas and snapshots into materialized view</li></ol><h2 id="server-must" tabindex="-1">Server MUST <a class="header-anchor" href="#server-must" aria-label="Permalink to &quot;Server MUST&quot;">​</a></h2><ol><li>Increment global revision counter on every state change</li><li>Store each operation with its revision in a ring buffer</li><li>For each client, compute delta (operations since <code>lastSentRev</code>)</li><li>If delta is unavailable (client too far behind), send full snapshot instead</li><li>Include revision metadata in state messages: <code>rev</code> for snapshots, <code>fromRev</code>/<code>toRev</code> for deltas</li><li>Track per-client <code>lastSentRev</code> to compute deltas correctly</li></ol><h2 id="client-must" tabindex="-1">Client MUST <a class="header-anchor" href="#client-must" aria-label="Permalink to &quot;Client MUST&quot;">​</a></h2><ol><li>Track <code>serverRev</code> from received messages</li><li>Apply incoming deltas in order (maintain FIFO)</li><li>Fall back to full refresh if <code>SNAPSHOT</code> received instead of deltas</li><li>Implement optimistic updates (apply pending ops before server confirmation)</li><li>Rebase pending operations after conflict resolution</li></ol><h2 id="recovery-strategy" tabindex="-1">Recovery Strategy <a class="header-anchor" href="#recovery-strategy" aria-label="Permalink to &quot;Recovery Strategy&quot;">​</a></h2><p>When a client falls too far behind (revision gap exceeds buffer size), the server:</p><ol><li>Sends a <code>REVISION_GAP</code> error message with metadata about the gap</li><li>Then sends a <strong>full snapshot</strong> for recovery</li></ol><p>The client discards pending operations and applies the snapshot, then resumes delta sync on subsequent updates.</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Client (offline 30s)     Server (rev=100, buffer=75-100)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    reconnect            &gt;</span></span>
<span class="line"><span>                             check: expected 50, have 75</span></span>
<span class="line"><span>                             (gap too large, send error + snapshot)</span></span>
<span class="line"><span>    &lt;   REVISION_GAP      $ expectedRev=50, serverRev=100, bufferFirstRev=75</span></span>
<span class="line"><span>    &lt;   snapshot         $ rev=100, state={}</span></span>
<span class="line"><span>    discard pending      $</span></span>
<span class="line"><span>    apply full state     $</span></span>
<span class="line"><span>    resume delta sync    $</span></span></code></pre></div><h2 id="timelines" tabindex="-1">Timelines <a class="header-anchor" href="#timelines" aria-label="Permalink to &quot;Timelines&quot;">​</a></h2><p><strong>Happy path (delta sync):</strong></p>`,21)),(a(),s(d,null,{default:t(()=>[o(n,{id:"mermaid-156",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20Client%0A%20%20%20%20participant%20Server%20as%20Server%20(rev%3D100)%0A%20%20%20%20Client-%3E%3EServer%3A%20connect%0A%20%20%20%20Note%20over%20Server%3A%20remember%3Cbr%2F%3ElastSentRev%3D0%0A%20%20%20%20Server-%3E%3EClient%3A%20snapshot%3Cbr%2F%3Erev%3D100%2C%20state%3D%7B%7D%0A%20%20%20%20Client-%3E%3EClient%3A%20lastRev%3D100%0A%20%20%20%20Client-%3E%3EClient%3A%20user%20action%3Cbr%2F%3E(pending%20op)%0A%20%20%20%20Server-%3E%3EClient%3A%20delta%3Cbr%2F%3Erev%3D101%2C%20ops%3D%5Bop1%5D%0A%20%20%20%20Client-%3E%3EClient%3A%20apply%20ops%3Cbr%2F%3ElastRev%3D101%0A"})]),fallback:t(()=>[...e[0]||(e[0]=[l(" Loading... ",-1)])]),_:1})),e[3]||(e[3]=r("p",null,[r("strong",null,"Far-behind recovery (snapshot fallback):")],-1)),(a(),s(d,null,{default:t(()=>[o(n,{id:"mermaid-160",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20Client%20as%20Client%20(offline%2030s)%0A%20%20%20%20participant%20Server%20as%20Server%20(rev%3D100%2C%3Cbr%2F%3Ebuffer%3D75-100)%0A%20%20%20%20Client-%3E%3EServer%3A%20reconnect%0A%20%20%20%20Note%20over%20Server%3A%20check%3A%20expected%2050%2C%20have%2075%3Cbr%2F%3E(gap%20too%20large%2C%3Cbr%2F%3Esend%20snapshot)%0A%20%20%20%20Server-%3E%3EClient%3A%20snapshot%3Cbr%2F%3Erev%3D100%2C%20state%3D%7B%7D%0A%20%20%20%20Client-%3E%3EClient%3A%20discard%20pending%3Cbr%2F%3Eapply%20full%20state%0A"})]),fallback:t(()=>[...e[1]||(e[1]=[l(" Loading... ",-1)])]),_:1})),e[4]||(e[4]=i('<h2 id="failure-modes" tabindex="-1">Failure Modes <a class="header-anchor" href="#failure-modes" aria-label="Permalink to &quot;Failure Modes&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Condition</th><th>Error</th><th>Retryable</th><th>Client Action</th></tr></thead><tbody><tr><td>Client far behind (rev gap &gt; buffer)</td><td><code>REVISION_GAP</code></td><td>yes</td><td>Receive <code>REVISION_GAP</code> metadata, then accept <code>SYNC.SNAPSHOT</code> and discard pending ops</td></tr><tr><td>Concurrent client updates</td><td>(via deltas)</td><td>n/a</td><td>Apply deltas in order, rebase pending ops, ack confirmed ops via <code>clientReqId</code></td></tr><tr><td>Unauthorized update</td><td><code>UNAUTHENTICATED</code></td><td>no</td><td>Reconnect with valid credentials and rejoin</td></tr></tbody></table><h2 id="key-implementation-details" tabindex="-1">Key Implementation Details <a class="header-anchor" href="#key-implementation-details" aria-label="Permalink to &quot;Key Implementation Details&quot;">​</a></h2><ol><li><strong>Ring Buffer</strong> — Fixed-size circular buffer prevents unbounded memory growth</li><li><strong>Revision Tracking</strong> — Allows efficient delta computation without full state copies</li><li><strong>Per-Client State</strong> — Each client has independent <code>lastSentRev</code> for personalized deltas</li><li><strong>Optimistic Updates</strong> — Apply pending ops locally before server confirmation</li><li><strong>Fallback Strategy</strong> — Send snapshots when buffer doesn&#39;t have enough history</li></ol><h2 id="conformance" tabindex="-1">Conformance <a class="header-anchor" href="#conformance" aria-label="Permalink to &quot;Conformance&quot;">​</a></h2><p>Delta sync ships with three fixtures validating core scenarios:</p><ol><li><strong>001-happy-path</strong> — Client joins, receives snapshot, then receives deltas on updates</li><li><strong>002-revision-gap</strong> — Client falls behind buffer, receives <code>REVISION_GAP</code> error + snapshot</li><li><strong>003-optimistic-update</strong> — Client sends update, receives server confirmation via <code>clientReqId</code></li></ol><p>Run conformance tests with:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bun</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> test</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> examples/delta-sync/conformance.test.ts</span></span></code></pre></div><h2 id="limitations" tabindex="-1">Limitations <a class="header-anchor" href="#limitations" aria-label="Permalink to &quot;Limitations&quot;">​</a></h2><ul><li>No persistence layer; in-memory ring buffer only</li><li>No automatic backpressure; assumes clients handle snapshots gracefully</li><li>No encryption; suitable for trusted networks only</li></ul>',11))])}const A=c(u,[["render",v]]);export{S as __pageData,A as default};
